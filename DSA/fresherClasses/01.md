# C++ Arrays, Vectors & Time Complexity - Complete Guide

## Table of Contents
1. [Arrays vs Vectors in C++](#arrays-vs-vectors)
2. [Finding Size: sizeof() vs size()](#finding-size)
3. [Time Complexity Basics](#time-complexity)
4. [Array Sorting & Checking](#array-operations)
5. [Problem: Find Second Largest Element](#second-largest-problem)

---

## Arrays vs Vectors in C++

### Arrays (Static)
```cpp
int arr[5] = {10, 2, 3, 4, 5};
```
- **Fixed size** - Size is determined at compile time
- **Cannot be resized** after declaration
- **Stored on stack** (for local arrays)
- **Faster** but less flexible
- **Memory efficient** - No overhead

### Vectors (Dynamic)
```cpp
vector<int> nums = {10, 2, 3, 4, 5};
```
- **Dynamic size** - Can grow/shrink at runtime
- **Can add/remove elements** using `push_back()`, `pop_back()`
- **Stored on heap**
- **Slightly slower** but very flexible
- **Extra memory** for dynamic allocation

---

## Finding Size: sizeof() vs size()

### For Arrays: Use `sizeof()`

```cpp
int arr[5] = {10, 2, 3, 4, 5};
int n = sizeof(arr) / sizeof(arr[0]);
```

**How it works:**
- 1 integer = 4 bytes
- `sizeof(arr)` = 4 × 5 = **20 bytes** (total array size)
- `sizeof(arr[0])` = **4 bytes** (size of one element)
- `20 / 4` = **5** (number of elements)

⚠️ **Important:** `sizeof()` only works for arrays declared in the same scope. If you pass an array to a function, it decays to a pointer, and `sizeof()` won't work correctly.

```cpp
void function(int arr[]) {
    int n = sizeof(arr) / sizeof(arr[0]); // ❌ WRONG! This gives pointer size
}
```

### For Vectors: Use `.size()`

```cpp
vector<int> nums = {10, 2, 3, 4, 5};
int n = nums.size(); // Returns 5
```

- `.size()` is a **member function** of the vector class
- Returns the **number of elements** directly
- **Always works** - even when passed to functions
- **Recommended** for vectors

### Quick Comparison

| Feature | Arrays | Vectors |
|---------|--------|---------|
| **Size calculation** | `sizeof(arr)/sizeof(arr[0])` | `nums.size()` |
| **Works in functions** | ❌ No (array decays to pointer) | ✅ Yes |
| **Return type** | `size_t` (unsigned) | `size_t` (unsigned) |
| **Best practice** | Pass size as parameter | Use `.size()` anywhere |

---

## Time Complexity Basics

### O(1) - Constant Time
```cpp
// Running a fixed number of times (e.g., 4 times)
for(int i = 0; i < 4; i++) {
    cout << i << endl;
}
```
**Time Complexity:** O(1) - Doesn't depend on input size

### O(n) - Linear Time
```cpp
// Loop running from 0 to n-1 (runs n times)
for(int i = 0; i < n; i++) {
    cout << arr[i] << endl;
}
```
**Time Complexity:** O(n)
- If n = 100, loop runs 100 times
- If n = 1000, loop runs 1000 times

**Note:** `n + 1` operations = O(n) because we ignore constants in Big O notation (n >>> 1)

### O(n × m) - Nested Loops
```cpp
// First loop runs n times
for(int i = 0; i < n; i++) {
    // Second loop runs m times
    for(int j = 0; j < m; j++) {
        // Do something
    }
}
```
**Time Complexity:** O(n × m)
- Outer loop: n iterations
- Inner loop: m iterations for each outer iteration
- Total: n × m operations

### O(n log n) - Sorting Algorithms
```cpp
sort(arr.begin(), arr.end()); // Uses merge sort internally
```
**Time Complexity:** O(n log n)

**Why log n?**
- 100 → 50 → 25 → 12.5 → 6.25 → ... (dividing by 2 each time)
- This happens **log₂(100) ≈ 7 times**
- Compare with: 100 → 99 → 98 → 97 → ... → 1 (n times)

**Merge Sort Process:**
- Divide array in half repeatedly: **log n times**
- Merge all parts back: **n operations at each level**
- Total: **n × log n**

---

## Array Operations

### Checking if Array is Sorted
```cpp
bool isSorted(int arr[], int n) {
    for (int i = 1; i < n; i++) {
        if (arr[i] < arr[i - 1])
            return false;
    }
    return true;
}
```

**Logic:**
- Compare each element with previous element
- If any element is smaller than previous → not sorted
- If loop completes → array is sorted

**Time Complexity:** O(n)

---

## Problem: Find Second Largest Element

### Problem Statement
Given an array/vector, find the **second largest element**.
- If no second largest exists, return **-1**

**Example:**
```
Input: [2, 5, 10]
Output: 5

Input: [8, 8, 8]
Output: -1 (all elements are same)

Input: [5]
Output: -1 (only one element)
```

---

### Solution Approach

#### ❌ Approach 1: Sorting (Brute Force)
```cpp
sort(nums.begin(), nums.end());
return nums[n-2]; // Second largest at n-2 position
```
**Time Complexity:** O(n log n) - Too slow!

---

#### ✅ Approach 2: Single Pass (Optimal)

**Main Idea:**
- Track two variables: `largest` and `secondLargest`
- Traverse array once and update both variables

**DSA Principle:**
> Every solution has two parts:
> 1. **Main logic** - Core algorithm
> 2. **Edge cases** - Handle special situations

---

### Step-by-Step Solution

#### Step 1: Handle Edge Cases
```cpp
int n = nums.size();

// Edge case: Array with less than 2 elements
if(n < 2) {
    return -1; // No second largest possible
}
```

#### Step 2: Initialize Variables
```cpp
int largest = INT_MIN;       // Smallest possible integer value
int secondLargest = INT_MIN; // Smallest possible integer value
```

**Why INT_MIN?**
- It's the smallest value an `int` can hold (-2,147,483,648)
- Any array element will be greater than this
- Ensures proper comparison from the start

---

### Step 3: Main Logic - Single Loop

```cpp
for(int i = 0; i < n; i++) {
    
    // Case 1: Found new largest element
    if(nums[i] > largest) {
        secondLargest = largest;  // Old largest becomes second largest
        largest = nums[i];         // Update largest
    }
    
    // Case 2: Found new second largest
    // Must be: smaller than largest AND not equal to largest
    else if(nums[i] > secondLargest && nums[i] != largest) {
        secondLargest = nums[i];
    }
}

return secondLargest;
```

---

### Dry Run Examples

#### Example 1: [2, 5, 10]
```
Initial: largest = INT_MIN, secondLargest = INT_MIN

i=0, nums[0]=2:
  2 > INT_MIN → largest = 2, secondLargest = INT_MIN

i=1, nums[1]=5:
  5 > 2 → secondLargest = 2, largest = 5

i=2, nums[2]=10:
  10 > 5 → secondLargest = 5, largest = 10

Result: secondLargest = 5 ✅
```

#### Example 2: [8, 8, 7, 6, 5]
```
Initial: largest = INT_MIN, secondLargest = INT_MIN

i=0, nums[0]=8:
  8 > INT_MIN → largest = 8, secondLargest = INT_MIN

i=1, nums[1]=8:
  8 = largest → Skip (not greater than largest)

i=2, nums[2]=7:
  7 < largest AND 7 != largest → secondLargest = 7

i=3, nums[3]=6:
  6 < secondLargest → Skip

i=4, nums[4]=5:
  5 < secondLargest → Skip

Result: secondLargest = 7 ✅
```

#### Example 3: [10, 8, 2]
```
Initial: largest = INT_MIN, secondLargest = INT_MIN

i=0, nums[0]=10:
  10 > INT_MIN → largest = 10, secondLargest = INT_MIN

i=1, nums[1]=8:
  8 < 10 AND 8 != 10 → secondLargest = 8

i=2, nums[2]=2:
  2 < secondLargest → Skip

Result: secondLargest = 8 ✅
```

---

### Complete Working Code

```cpp
class Solution {
public:
    int secondLargestElement(vector<int>& nums) {
        int n = nums.size();
        
        // Edge case: Less than 2 elements
        if(n < 2) {
            return -1;
        }
        
        int largest = INT_MIN;
        int secondLargest = INT_MIN;
        
        // Single pass through array
        for(int i = 0; i < n; i++) {
            if(nums[i] > largest) {
                secondLargest = largest;
                largest = nums[i];
            }
            else if(nums[i] > secondLargest && nums[i] != largest) {
                secondLargest = nums[i];
            }
        }
        
        // Edge case: All elements are same
        if(secondLargest == INT_MIN) {
            return -1;
        }
        
        return secondLargest;
    }
};
```

---

### Why This Approach Works

**Key Insights:**

1. **Two conditions for second largest:**
   - Must be less than largest
   - Must NOT equal largest (handles duplicates)

2. **Order matters:**
   - Check largest first
   - Then check second largest with additional condition

3. **Handles edge cases:**
   - Single element: `n < 2`
   - All same elements: `secondLargest == INT_MIN`
   - Duplicates: `nums[i] != largest` condition

**Time Complexity:** O(n) - Single pass through array
**Space Complexity:** O(1) - Only two variables

---

## Key Takeaways

1. **Arrays:** Use `sizeof(arr)/sizeof(arr[0])` (only in same scope)
2. **Vectors:** Use `nums.size()` (works everywhere)
3. **Time Complexity:** 
   - Single loop = O(n)
   - Nested loops = O(n × m)
   - Sorting = O(n log n)
4. **Problem Solving:**
   - Handle edge cases first
   - Think about the main logic
   - Optimize step by step
5. **Second Largest:**
   - Track two variables
   - Single pass solution
   - Handle duplicates carefully

---
