# ğŸš€ DSA Notes â€” Sliding Window + Binary Search + LB/UB + Single Element Problem

These notes cover **complete intuition + approaches + diagrams + code** for:

* Sliding Window (beginner â†’ advanced)
* Longest Substring Without Repeating Characters
* lower_bound / upper_bound (LB & UB)
* Count Occurrence in Sorted Array
* Single Element in Sorted Array (Binary Search Pattern)

---

# â­ 1. Sliding Window â€” Complete Guide

A "window" is a range inside the array/string maintained using two pointers:

```
start ---- end
```

The window **expands** by moving `end` and **shrinks** by moving `start`.

We have 3 types:

---

## âœ… Type 1: Fixed-Size Sliding Window

### Use when window size (k) is **given**.

**Example:** Maximum sum of subarray of size k

**Pattern:**

```
add arr[end]
if window size > k: remove arr[start] & start++
```

**Code:**

```cpp
int maxSum(vector<int>& arr, int k) {
    int sum = 0, mx = 0;
    int start = 0;
    for (int end = 0; end < arr.size(); end++) {
        sum += arr[end];
        if (end - start + 1 == k) {
            mx = max(mx, sum);
            sum -= arr[start];
            start++;
        }
    }
    return mx;
}
```

---

## âœ… Type 2: Variable-Size Sliding Window

Use when window size is **not fixed**, but depends on a **condition**.

Common problems:

* Longest substring with K distinct characters
* Longest substring without repeating characters

**Pattern:**

```
for end:
    include element
    while window breaks condition:
        shrink start
    update answer
```

---

## â­ The Most Asked Sliding Window Problem

# **Longest Substring Without Repeating Characters (LeetCode 3)**

### ğŸ¯ Goal

Given string `"abcabcbb"`, find longest substring with **no repeats**.

Answer â†’ `"abc"` â†’ length = **3**

---

## âš™ï¸ Intuition Step-by-Step

Use:

* `start` pointer (left side of window)
* `end` pointer (right side)
* `last[256]` array to store last index of each character

### Why 256?

Because ASCII characters = **256**, and string characters always come from this set.

### Why initialize with -1?

Because initially, **no character is seen yet**.

```
last['a'] = -1 â†’ means 'a' never appeared before
```

---

## ğŸ§ª Dry Run on â€œabbaâ€

```
index: 0 1 2 3
char : a b b a
```

â¡ï¸ `start = 0`, `end = 0`, char = 'a'

```
window = "a"
maxLen = 1
```

â¡ï¸ `end = 1`, char = 'b'

```
window = "ab"
maxLen = 2
```

â¡ï¸ `end = 2`, char = 'b' (REPEAT!)

```
last['b'] = 1 >= start(0)
so start = 1 + 1 = 2
```

Window becomes:

```
"b"
maxLen = 2
```

â¡ï¸ `end = 3`, char = 'a'

```
last['a'] = 0 < start(2) â†’ safe
window = "ba"
maxLen = 2
```

Final â†’ **2**

---

## âœ”ï¸ Final Code (Best + Clean)

```cpp
int lengthOfLongestSubstring(string s) {
    vector<int> last(256, -1);
    int start = 0, maxLength = 0;

    for (int end = 0; end < s.size(); end++) {
        char c = s[end];

        if (last[c] >= start) {
            start = last[c] + 1;
        }

        last[c] = end;
        maxLength = max(maxLength, end - start + 1);
    }
    return maxLength;
}
```

---

# â­ 2. lower_bound & upper_bound

### âœ”ï¸ lower_bound(arr, x)

Gives index of **first element >= x**

### âœ”ï¸ upper_bound(arr, x)

Gives index of **first element > x**

### ğŸ¯ Count occurrences of x

```
count = ub - lb
```

### âœ”ï¸ Code

```cpp
int countOcc(vector<int>& arr, int x) {
    auto lb = lower_bound(arr.begin(), arr.end(), x);
    auto ub = upper_bound(arr.begin(), arr.end(), x);
    return ub - lb;
}
```

---

# â­ 3. Single Element in Sorted Array (Binary Search Trick)

(LeetCode 540)

Array where:

* every element appears **twice**
* EXCEPT one element appears **once**

Example:

```
1 1 2 3 3 4 4 8 8
```

---

# ğŸ§  Intuition: Pattern Before + After Single Element

Before single element:

```
even index â†’ first of pair
odd index  â†’ second
```

After single element:

```
odd index â†’ first of pair
even index â†’ second
```

So single element **breaks the pattern**.

---

# ğŸ”¥ Binary Search Logic

1. Always make `mid` **even**
2. Compare `nums[mid]` with `nums[mid+1]`

### Case 1: Pattern correct (even == next)

Single element is on RIGHT

```
low = mid + 2
```

### Case 2: Pattern broken

Single element is on LEFT

```
high = mid
```

Stop when `low == high` â†’ answer.

---

# âœ”ï¸ Code

```cpp
int singleNonDuplicate(vector<int>& nums) {
    int low = 0, high = nums.size() - 1;

    while (low < high) {
        int mid = (low + high) / 2;
        if (mid % 2 == 1) mid--; // force mid to be even

        if (nums[mid] == nums[mid + 1]) {
            low = mid + 2;
        } else {
            high = mid;
        }
    }
    return nums[low];
}
```

---

# ğŸ¯ Quick Summary (Cheat Sheet)

### â­ Sliding Window

* Fixed window â†’ size k
* Variable window â†’ condition
* Unique substring â†’ use last-seen array

### â­ LB/UB

* LB â†’ first >= x
* UB â†’ first > x
* Count = ub âˆ’ lb

### â­ Single Element (Binary Search)

* mid must be even
* if nums[mid] == nums[mid+1] â†’ go right
* else â†’ go left

---
