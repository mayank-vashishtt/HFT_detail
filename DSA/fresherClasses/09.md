# LeetCode Problems Guide: Basic to Advanced (C++)

A comprehensive guide covering fundamental to advanced problem-solving techniques with detailed intuition and multiple approaches.

---

## Table of Contents
1. [Palindrome Number](#1-palindrome-number)
2. [Search Insert Position](#2-search-insert-position)
3. [Power(x, n)](#3-powerx-n)
4. [Generate Parentheses](#4-generate-parentheses)
5. [Length of Longest Substring Without Repeating Characters](#5-length-of-longest-substring-without-repeating-characters)
6. [Max Consecutive Ones III](#6-max-consecutive-ones-iii)
7. [Fruit Into Baskets](#7-fruit-into-baskets)
8. [Longest Repeating Character Replacement](#8-longest-repeating-character-replacement)

---

## 1. Palindrome Number

**Difficulty:** Easy  
**Topics:** Math, String Manipulation

### Problem Statement
Determine if an integer is a palindrome. An integer is a palindrome when it reads the same backward as forward.

**Example:**
```
Input: x = 121
Output: true

Input: x = -121
Output: false (reads as 121- from right to left)

Input: x = 10
Output: false (reads as 01 from right to left)
```

### Intuition

**Basic Idea:** A palindrome reads the same forwards and backwards. For numbers, we can either:
1. Convert to string and compare (easy but uses extra space)
2. Reverse the number mathematically and compare (optimal)

**Key Observations:**
- Negative numbers are never palindromes
- Numbers ending in 0 (except 0 itself) are never palindromes
- We only need to reverse half the number to check

### Approach 1: String Conversion (Basic)

**Intuition:** Convert number to string, then compare with its reverse.

```cpp
class Solution {
public:
    bool isPalindrome(int x) {
        string s = to_string(x);
        string rev = s;
        reverse(rev.begin(), rev.end());
        return s == rev;
    }
};
```

**Complexity:**
- Time: O(n) where n is number of digits
- Space: O(n) for string storage

### Approach 2: Mathematical Reversal (Optimal)

**Intuition:** Reverse the number digit by digit and compare with original.

```cpp
class Solution {
public:
    bool isPalindrome(int x) {
        // Negative numbers and numbers ending in 0 (except 0) are not palindromes
        if (x < 0 || (x % 10 == 0 && x != 0)) {
            return false;
        }
        
        long long reversed = 0;
        int original = x;
        
        while (x > 0) {
            int digit = x % 10;              // Extract last digit
            reversed = reversed * 10 + digit; // Build reversed number
            x /= 10;                          // Remove last digit
        }
        
        return original == reversed;
    }
};
```

### Approach 3: Half Reversal (Most Optimal)

**Intuition:** We only need to reverse half the digits. When reversed half equals remaining half, it's a palindrome.

```cpp
class Solution {
public:
    bool isPalindrome(int x) {
        // Edge cases
        if (x < 0 || (x % 10 == 0 && x != 0)) {
            return false;
        }
        
        int reversedHalf = 0;
        
        // Reverse only half of the number
        while (x > reversedHalf) {
            reversedHalf = reversedHalf * 10 + x % 10;
            x /= 10;
        }
        
        // For even length: x == reversedHalf
        // For odd length: x == reversedHalf / 10 (ignore middle digit)
        return x == reversedHalf || x == reversedHalf / 10;
    }
};
```

**Complexity:**
- Time: O(log n) - only process half the digits
- Space: O(1)

---

## 2. Search Insert Position

**Difficulty:** Easy  
**Topics:** Binary Search, Array

### Problem Statement
Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.

**Example:**
```
Input: nums = [1,3,5,6], target = 5
Output: 2

Input: nums = [1,3,5,6], target = 2
Output: 1

Input: nums = [1,3,5,6], target = 7
Output: 4
```

### Intuition

**Basic Idea:** This is a classic binary search problem. Since the array is sorted, we can efficiently find the position in O(log n) time.

**Key Observations:**
- Array is sorted - hints at binary search
- Need to find exact position or insertion point
- Binary search naturally gives us the insertion position

### Approach 1: Linear Search (Basic)

**Intuition:** Scan through array until we find target or a number greater than target.

```cpp
class Solution {
public:
    int searchInsert(vector<int>& nums, int target) {
        for (int i = 0; i < nums.size(); i++) {
            if (nums[i] >= target) {
                return i;
            }
        }
        return nums.size(); // Insert at end
    }
};
```

**Complexity:**
- Time: O(n)
- Space: O(1)

### Approach 2: Binary Search (Optimal)

**Intuition:** Use binary search to find the leftmost position where target should be inserted.

```cpp
class Solution {
public:
    int searchInsert(vector<int>& nums, int target) {
        int left = 0, right = nums.size() - 1;
        
        while (left <= right) {
            int mid = left + (right - left) / 2; // Avoid overflow
            
            if (nums[mid] == target) {
                return mid; // Found target
            } else if (nums[mid] < target) {
                left = mid + 1; // Search right half
            } else {
                right = mid - 1; // Search left half
            }
        }
        
        // left is the insertion position
        return left;
    }
};
```

**Why `left` is the answer?**
- When loop ends, `left > right`
- `right` points to last element < target
- `left` points to first element >= target (insertion point)

**Complexity:**
- Time: O(log n)
- Space: O(1)

---

## 3. Power(x, n)

**Difficulty:** Medium  
**Topics:** Math, Recursion, Binary Exponentiation

### Problem Statement
Implement `pow(x, n)`, which calculates x raised to the power n.

**Example:**
```
Input: x = 2.0, n = 10
Output: 1024.0

Input: x = 2.0, n = -2
Output: 0.25
```

### Intuition

**Basic Idea:** We need to multiply x by itself n times. But doing this naively is O(n). We can optimize using **binary exponentiation**.

**Key Insight:** 
- x^8 = (x^4)^2 = ((x^2)^2)^2
- We can reduce multiplications from 8 to 3!
- For odd powers: x^9 = x * x^8

### Approach 1: Brute Force (Basic)

**Intuition:** Multiply x by itself n times.

```cpp
class Solution {
public:
    double myPow(double x, int n) {
        if (n == 0) return 1.0;
        
        long long N = n;
        if (N < 0) {
            x = 1 / x;
            N = -N;
        }
        
        double result = 1.0;
        for (long long i = 0; i < N; i++) {
            result *= x;
        }
        
        return result;
    }
};
```

**Complexity:**
- Time: O(n) - TLE for large n
- Space: O(1)

### Approach 2: Binary Exponentiation - Recursive (Optimal)

**Intuition:** 
- If n is even: x^n = (x^(n/2))^2
- If n is odd: x^n = x * x^(n-1)

```cpp
class Solution {
public:
    double myPow(double x, int n) {
        if (n == 0) return 1.0;
        if (n == 1) return x;
        
        long long N = n;
        if (N < 0) {
            x = 1 / x;
            N = -N;
        }
        
        return power(x, N);
    }
    
private:
    double power(double x, long long n) {
        if (n == 0) return 1.0;
        if (n == 1) return x;
        
        double half = power(x, n / 2);
        
        if (n % 2 == 0) {
            return half * half;        // Even power
        } else {
            return x * half * half;    // Odd power
        }
    }
};
```

**Complexity:**
- Time: O(log n)
- Space: O(log n) - recursion stack

### Approach 3: Binary Exponentiation - Iterative (Most Optimal)

**Intuition:** Use binary representation of n. For each bit that's 1, multiply result by corresponding power.

Example: 
- 13 = 1101₂ = 8 + 4 + 1
- x^13 = x^8 * x^4 * x^1

```cpp
class Solution {
public:
    double myPow(double x, int n) {
        long long N = n;
        if (N < 0) {
            x = 1 / x;
            N = -N;
        }
        
        double result = 1.0;
        double currentProduct = x;
        
        while (N > 0) {
            if (N % 2 == 1) {  // If current bit is 1
                result *= currentProduct;
            }
            currentProduct *= currentProduct; // Square for next bit
            N /= 2; // Move to next bit
        }
        
        return result;
    }
};
```

**Complexity:**
- Time: O(log n)
- Space: O(1)

---

## 4. Generate Parentheses

**Difficulty:** Medium  
**Topics:** Backtracking, Recursion, String

### Problem Statement
Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.

**Example:**
```
Input: n = 3
Output: ["((()))","(()())","(())()","()(())","()()()"]

Input: n = 1
Output: ["()"]
```

### Intuition

**Basic Idea:** This is a classic backtracking problem. We need to build valid parentheses combinations by making choices at each step.

**Key Rules for Valid Parentheses:**
1. We can add '(' if we haven't used all n opening brackets
2. We can add ')' only if there are more '(' than ')' so far
3. Valid combination has exactly n '(' and n ')'

**Think of it as a decision tree:**
```
                    ""
                /        \
              "("         (can't start with ')')
            /    \
         "(("    "()"
        /  \      / \
      ...   ...  ... ...
```

### Approach: Backtracking

**Intuition:** Build strings character by character, backtrack when we reach dead ends or complete combinations.

```cpp
class Solution {
public:
    vector<string> generateParenthesis(int n) {
        vector<string> result;
        string current = "";
        backtrack(result, current, 0, 0, n);
        return result;
    }
    
private:
    void backtrack(vector<string>& result, string& current, 
                   int open, int close, int max) {
        // Base case: we've used all parentheses
        if (current.length() == max * 2) {
            result.push_back(current);
            return;
        }
        
        // Add '(' if we haven't used all opening brackets
        if (open < max) {
            current += '(';
            backtrack(result, current, open + 1, close, max);
            current.pop_back(); // Backtrack
        }
        
        // Add ')' if it would create a valid combination
        if (close < open) {
            current += ')';
            backtrack(result, current, open, close + 1, max);
            current.pop_back(); // Backtrack
        }
    }
};
```

**Dry Run for n = 2:**
```
Start: current="", open=0, close=0

Step 1: Add '(' → current="(", open=1, close=0
  Step 2: Add '(' → current="((", open=2, close=0
    Step 3: Add ')' → current="(()", open=2, close=1
      Step 4: Add ')' → current="(())", open=2, close=2 ✓ Add to result
      Backtrack to Step 3
    Backtrack to Step 2
  Step 2: Add ')' → current="()", open=1, close=1
    Step 3: Add '(' → current="()(", open=2, close=1
      Step 4: Add ')' → current="()()", open=2, close=2 ✓ Add to result

Result: ["(())", "()()"]
```

**Complexity:**
- Time: O(4^n / √n) - Catalan number
- Space: O(n) - recursion depth

---

## 5. Length of Longest Substring Without Repeating Characters

**Difficulty:** Medium  
**Topics:** Sliding Window, Hash Table, Two Pointers

### Problem Statement
Given a string s, find the length of the longest substring without repeating characters.

**Example:**
```
Input: s = "abcabcbb"
Output: 3
Explanation: "abc" is the longest substring without repeating characters

Input: s = "bbbbb"
Output: 1

Input: s = "pwwkew"
Output: 3
Explanation: "wke" is the longest substring
```

### Intuition

**Basic Idea:** Use a sliding window approach. Expand window when characters are unique, shrink when we find duplicates.

**Key Insight:**
- Maintain a window [left, right]
- Use hash map to track last seen position of each character
- When duplicate found, move left pointer past the previous occurrence

**Visual Example:** s = "abcabcbb"
```
Window: [a b c] a b c b b → length = 3
        a [b c a] b c b b → length = 3
        a b [c a b] c b b → length = 3
```

### Approach 1: Brute Force (Basic)

**Intuition:** Check all possible substrings.

```cpp
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        int maxLen = 0;
        int n = s.length();
        
        for (int i = 0; i < n; i++) {
            unordered_set<char> seen;
            for (int j = i; j < n; j++) {
                if (seen.count(s[j])) {
                    break; // Duplicate found
                }
                seen.insert(s[j]);
                maxLen = max(maxLen, j - i + 1);
            }
        }
        
        return maxLen;
    }
};
```

**Complexity:**
- Time: O(n²)
- Space: O(min(n, m)) where m is charset size

### Approach 2: Sliding Window with Set (Better)

**Intuition:** Use two pointers and expand/shrink window dynamically.

```cpp
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        unordered_set<char> charSet;
        int left = 0, maxLen = 0;
        
        for (int right = 0; right < s.length(); right++) {
            // Shrink window until no duplicate
            while (charSet.count(s[right])) {
                charSet.erase(s[left]);
                left++;
            }
            
            charSet.insert(s[right]);
            maxLen = max(maxLen, right - left + 1);
        }
        
        return maxLen;
    }
};
```

**Complexity:**
- Time: O(2n) = O(n) - each character visited at most twice
- Space: O(min(n, m))

### Approach 3: Sliding Window with HashMap (Optimal)

**Intuition:** Instead of shrinking one by one, jump left pointer directly past the duplicate.

```cpp
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        unordered_map<char, int> lastSeen; // char -> last index
        int left = 0, maxLen = 0;
        
        for (int right = 0; right < s.length(); right++) {
            char currentChar = s[right];
            
            // If character seen before and is in current window
            if (lastSeen.count(currentChar) && lastSeen[currentChar] >= left) {
                // Move left pointer past the last occurrence
                left = lastSeen[currentChar] + 1;
            }
            
            lastSeen[currentChar] = right;
            maxLen = max(maxLen, right - left + 1);
        }
        
        return maxLen;
    }
};
```

**Dry Run:** s = "abcabcbb"
```
right=0, s[0]='a': lastSeen={'a':0}, left=0, maxLen=1
right=1, s[1]='b': lastSeen={'a':0,'b':1}, left=0, maxLen=2
right=2, s[2]='c': lastSeen={'a':0,'b':1,'c':2}, left=0, maxLen=3
right=3, s[3]='a': 'a' seen at 0, left=1, maxLen=3
right=4, s[4]='b': 'b' seen at 1, left=2, maxLen=3
right=5, s[5]='c': 'c' seen at 2, left=3, maxLen=3
...
```

**Complexity:**
- Time: O(n) - each character visited once
- Space: O(min(n, m))

---

## 6. Max Consecutive Ones III

**Difficulty:** Medium  
**Topics:** Sliding Window, Two Pointers

### Problem Statement
Given a binary array nums and an integer k, return the maximum number of consecutive 1's in the array if you can flip at most k 0's.

**Example:**
```
Input: nums = [1,1,1,0,0,0,1,1,1,1,0], k = 2
Output: 6
Explanation: Flip two 0's at indices 4 and 5
Result: [1,1,1,0,0,1,1,1,1,1,1] → 6 consecutive 1's

Input: nums = [0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1], k = 3
Output: 10
```

### Intuition

**Basic Idea:** Use sliding window. Expand window while we have flips available, shrink when we exceed k flips.

**Key Insight:**
- Maintain a window with at most k zeros
- Count of zeros in window = flips used
- Window size = consecutive ones (including flipped zeros)

**Reframe the problem:**
"Find the longest subarray with at most k zeros"

### Approach: Sliding Window

**Intuition:** 
1. Expand right pointer to include elements
2. Track count of zeros in window
3. When zeros > k, shrink from left
4. Track maximum window size

```cpp
class Solution {
public:
    int longestOnes(vector<int>& nums, int k) {
        int left = 0, right = 0;
        int zeroCount = 0;
        int maxLen = 0;
        
        while (right < nums.size()) {
            // Expand window
            if (nums[right] == 0) {
                zeroCount++;
            }
            
            // Shrink window if too many zeros
            while (zeroCount > k) {
                if (nums[left] == 0) {
                    zeroCount--;
                }
                left++;
            }
            
            // Update maximum length
            maxLen = max(maxLen, right - left + 1);
            right++;
        }
        
        return maxLen;
    }
};
```

**Dry Run:** nums = [1,1,1,0,0,0,1,1,1,1,0], k = 2
```
Window: [1,1,1,0,0] → zeros=2, len=5
        [1,1,1,0,0,0] → zeros=3 > k, shrink
        [1,1,0,0,0] → zeros=3, shrink
        [1,0,0,0] → zeros=3, shrink
        [0,0,0] → zeros=3, shrink
        [0,0,1] → zeros=2, len=3
        [0,0,1,1] → zeros=2, len=4
        [0,0,1,1,1] → zeros=2, len=5
        [0,0,1,1,1,1] → zeros=2, len=6 ✓
```

**Optimized Version:** Don't shrink, just slide window

```cpp
class Solution {
public:
    int longestOnes(vector<int>& nums, int k) {
        int left = 0, right = 0;
        int zeroCount = 0;
        
        for (right = 0; right < nums.size(); right++) {
            if (nums[right] == 0) {
                zeroCount++;
            }
            
            // Just slide the window, don't shrink
            if (zeroCount > k) {
                if (nums[left] == 0) {
                    zeroCount--;
                }
                left++;
            }
        }
        
        return right - left; // Final window size is the answer
    }
};
```

**Why this works?**
- We never decrease window size
- Only increase or maintain size
- Final window size = maximum found

**Complexity:**
- Time: O(n)
- Space: O(1)

---

## 7. Fruit Into Baskets

**Difficulty:** Medium  
**Topics:** Sliding Window, Hash Table

### Problem Statement
You are visiting a farm with a row of fruit trees. Each tree produces one type of fruit. You have two baskets, each can hold unlimited fruit, but each basket can only hold one type of fruit. You want to collect as much fruit as possible starting from any tree. Return the maximum number of fruits you can collect.

**Rules:**
- Start at any tree
- Move right only
- Each basket holds one fruit type
- Can only use two baskets

**Example:**
```
Input: fruits = [1,2,1]
Output: 3
Explanation: Collect all fruits

Input: fruits = [0,1,2,2]
Output: 3
Explanation: Collect [1,2,2]

Input: fruits = [1,2,3,2,2]
Output: 4
Explanation: Collect [2,3,2,2]
```

### Intuition

**Reframe:** Find the longest subarray with at most 2 distinct elements.

**Key Insight:**
- Use sliding window with hash map
- Track fruit types in current window
- Shrink when we have > 2 types

**Visual:** fruits = [1,2,3,2,2]
```
Window: [1,2] → 2 types, len=2
        [1,2,3] → 3 types > 2, shrink
        [2,3] → 2 types, len=2
        [2,3,2] → 2 types, len=3
        [2,3,2,2] → 2 types, len=4 ✓
```

### Approach: Sliding Window with HashMap

```cpp
class Solution {
public:
    int totalFruit(vector<int>& fruits) {
        unordered_map<int, int> basket; // fruitType -> count
        int left = 0, maxFruits = 0;
        
        for (int right = 0; right < fruits.size(); right++) {
            // Add fruit to basket
            basket[fruits[right]]++;
            
            // Shrink window if more than 2 types
            while (basket.size() > 2) {
                basket[fruits[left]]--;
                if (basket[fruits[left]] == 0) {
                    basket.erase(fruits[left]);
                }
                left++;
            }
            
            // Update maximum
            maxFruits = max(maxFruits, right - left + 1);
        }
        
        return maxFruits;
    }
};
```

**Dry Run:** fruits = [1,2,3,2,2]
```
right=0: basket={1:1}, left=0, max=1
right=1: basket={1:1,2:1}, left=0, max=2
right=2: basket={1:1,2:1,3:1} → size=3 > 2
         Remove fruits[0]=1: basket={2:1,3:1}, left=1, max=2
right=3: basket={2:2,3:1}, left=1, max=3
right=4: basket={2:3,3:1}, left=1, max=4
```

**Alternative: Track Last Positions**

```cpp
class Solution {
public:
    int totalFruit(vector<int>& fruits) {
        unordered_map<int, int> lastPos; // fruitType -> last index
        int left = 0, maxFruits = 0;
        
        for (int right = 0; right < fruits.size(); right++) {
            lastPos[fruits[right]] = right;
            
            // If more than 2 types, remove the leftmost type
            if (lastPos.size() > 2) {
                int minPos = INT_MAX;
                int removeType = -1;
                
                for (auto& [fruit, pos] : lastPos) {
                    if (pos < minPos) {
                        minPos = pos;
                        removeType = fruit;
                    }
                }
                
                left = minPos + 1;
                lastPos.erase(removeType);
            }
            
            maxFruits = max(maxFruits, right - left + 1);
        }
        
        return maxFruits;
    }
};
```

**Complexity:**
- Time: O(n)
- Space: O(1) - at most 3 entries in map

---

## 8. Longest Repeating Character Replacement

**Difficulty:** Medium  
**Topics:** Sliding Window, Hash Table

### Problem Statement
You are given a string s and an integer k. You can choose any character and change it to any other uppercase English character at most k times. Return the length of the longest substring containing the same letter after performing the operations.

**Example:**
```
Input: s = "ABAB", k = 2
Output: 4
Explanation: Replace 'A' with 'B' (or vice versa) → "BBBB"

Input: s = "AABABBA", k = 1
Output: 4
Explanation: Replace one 'B' → "AAAA" or "BBBB"
```

### Intuition

**Key Insight:** 
- In a window of length L, if the most frequent character appears maxFreq times
- We need to replace (L - maxFreq) characters
- If (L - maxFreq) ≤ k, the window is valid

**Formula:**
```
windowLength - maxFrequency ≤ k
```

**Example:** s = "AABABBA", k = 1
```
Window "AABA": 
  - A appears 3 times (max)
  - Length = 4
  - Changes needed = 4 - 3 = 1 ≤ k ✓
```

### Approach 1: Sliding Window (Standard)

**Intuition:**
1. Expand window by adding characters
2. Track frequency of each character
3. Check if current window is valid
4. Shrink if invalid

```cpp
class Solution {
public:
    int characterReplacement(string s, int k) {
        unordered_map<char, int> count;
        int left = 0, maxFreq = 0, maxLen = 0;
        
        for (int right = 0; right < s.length(); right++) {
            // Add current character
            count[s[right]]++;
            maxFreq = max(maxFreq, count[s[right]]);
            
            // Check if window is valid
            int windowLen = right - left + 1;
            int replacements = windowLen - maxFreq;
            
            // Shrink if invalid
            if (replacements > k) {
                count[s[left]]--;
                left++;
            }
            
            maxLen = max(maxLen, right - left + 1);
        }
        
        return maxLen;
    }
};
```

**Dry Run:** s = "AABABBA", k = 1
```
right=0: s[0]='A', count={'A':1}, maxFreq=1, valid, maxLen=1
right=1: s[1]='A', count={'A':2}, maxFreq=2, valid, maxLen=2
right=2: s[2]='B', count={'A':2,'B':1}, maxFreq=2
         windowLen=3, replacements=3-2=1 ≤ k, valid, maxLen=3
right=3: s[3]='A', count={'A':3,'B':1}, maxFreq=3
         windowLen=4, replacements=4-3=1 ≤ k, valid, maxLen=4
right=4: s[4]='B', count={'A':3,'B':2}, maxFreq=3
         windowLen=5, replacements=5-3=2 > k, shrink
         Remove s[0]='A': count={'A':2,'B':2}, left=1
right=5: s[5]='B', count={'A':2,'B':3}, maxFreq=3
         windowLen=5, replacements=5-3=2 > k, shrink
...
```

### Approach 2: Optimized Sliding Window

**Intuition:** We don't need to recompute maxFreq when shrinking. We only care about finding a larger window.

```cpp
class Solution {
public:
    int characterReplacement(string s, int k) {
        vector<int> count(26, 0);
        int left = 0, maxFreq = 0;
        
        for (int right = 0; right < s.length(); right++) {
            // Update frequency and maxFreq
            count[s[right] - 'A']++;
            maxFreq = max(maxFreq, count[s[right] - 'A']);
            
            // If invalid, slide window
            if (right - left + 1 - maxFreq > k) {
                count[s[left] - 'A']--;
                left++;
            }
        }
        
        return s.length() - left;
    }
};
```

**Why don't we update maxFreq when shrinking?**
- We only care about finding a **larger** valid window
- If maxFreq decreases, the window won't be larger anyway
- So we can keep the old maxFreq; it only affects whether we find a bigger window

**Example Why This Works:**
```
Current window: "AAAB" with maxFreq=3, k=1
- Valid: 4 - 3 = 1 ≤ k

Try to expand: "AAABB" with maxFreq=3, k=1
- Invalid: 5 - 3 = 2 > k
- Slide window, but keep maxFreq=3
- We're looking for windows with maxFreq ≥ 3 now
- Smaller maxFreq won't give us bigger windows
```

**Complexity:**
- Time: O(n)
- Space: O(1) - fixed size array of 26

---

## Summary: Pattern Recognition

### 1. **Palindrome Pattern**
- **When to use:** Checking if something reads the same forwards/backwards
- **Techniques:** Two pointers, string reversal, half-comparison
- **Optimization:** Only check half the elements

### 2. **Binary Search Pattern**
- **When to use:** Sorted array, need O(log n) search
- **Key insight:** Halve search space each iteration
- **Remember:** `mid = left + (right - left) / 2` to avoid overflow

### 3. **Binary Exponentiation Pattern**
- **When to use:** Computing powers, repeated squaring needed
- **Key insight:** x^n = (x^(n/2))^2
- **Application:** Fast power, matrix exponentiation

### 4. **Backtracking Pattern**
- **When to use:** Generate all combinations/permutations
- **Structure:** Make choice → Recurse → Undo choice
- **Think:** Decision tree exploration

### 5. **Sliding Window Pattern**
- **When to use:** Subarray/substring problems with constraints
- **Two variations:**
  - **Fixed size:** Move both pointers together
  - **Variable size:** Expand right, shrink left when invalid
- **Common problems:**
  - At most K distinct elements
  - At most K replacements/flips
  - Longest substring without repeating characters

---

## Sliding Window Deep Dive

Since multiple problems above use sliding window, here's a comprehensive template:

### Generic Sliding Window Template

```cpp
int slidingWindow(vector<int>& arr, int k) {
    int left = 0, right = 0;
    int result = 0;
    // Data structure to track window state (map, set, counters, etc.)
    
    while (right < arr.size()) {
        // 1. Expand window - add arr[right]
        // Update window state
        
        // 2. Check if window is valid
        while (/* window is invalid */) {
            // Shrink window - remove arr[left]
            // Update window state
            left++;
        }
        
        // 3. Update result with current valid window
        result = max(result, right - left + 1);
        
        right++;
    }
    
    return result;
}
```

### When to Use Sliding Window?

✅ **Use sliding window when:**
- Problem asks for contiguous subarray/substring
- Need to find max/min length satisfying condition
- Keywords: "consecutive", "contiguous", "substring", "subarray"
- Constraint can be maintained by adding/removing elements

❌ **Don't use sliding window when:**
- Need non-contiguous elements
- Order doesn't matter
- Need all combinations/permutations

### Sliding Window Problem Types

| Problem Type | Approach | Example |
|-------------|----------|---------|
| **Fixed Window Size** | Slide window of size k | Max sum of k consecutive elements |
| **At Most K Distinct** | Shrink when distinct > k | Longest Substring with K Distinct |
| **At Most K Changes** | Shrink when changes > k | Max Consecutive 1s III |
| **No Repeating** | Shrink when duplicate found | Longest Substring Without Repeating |

---

## Problem Difficulty Progression

### Easy → Medium → Hard Journey

**Level 1: Easy (Foundation)**
1. ✅ Palindrome Number - Basic logic, math operations
2. ✅ Search Insert Position - Binary search basics

**Level 2: Medium (Building Skills)**
3. ✅ Power(x, n) - Recursive thinking, optimization
4. ✅ Max Consecutive Ones III - Sliding window introduction
5. ✅ Longest Substring Without Repeating - Hash table + sliding window
6. ✅ Fruit Into Baskets - Sliding window variation
7. ✅ Longest Repeating Character Replacement - Advanced sliding window

**Level 3: Medium-Hard (Advanced)**
8. ✅ Generate Parentheses - Backtracking, decision trees

---

## Key Takeaways & Tips

### 1. **Time Complexity Hierarchy**
```
O(1) < O(log n) < O(n) < O(n log n) < O(n²) < O(2^n) < O(n!)
```

**What to aim for:**
- Array search: O(log n) with binary search
- String/array traversal: O(n) single pass
- Avoid O(n²) nested loops when possible

### 2. **Space-Time Tradeoff**
- Hash table: O(n) space for O(1) lookup
- Binary search: O(1) space but need sorted array
- Recursion: O(h) space for call stack (h = height)

### 3. **Common Optimization Techniques**
1. **Hash Table:** Trade space for time
2. **Two Pointers:** Process array in one pass
3. **Sliding Window:** Avoid redundant computation
4. **Binary Search:** Halve search space
5. **Recursion + Memoization:** Avoid recomputation

### 4. **Problem-Solving Framework**

**Step 1: Understand**
- What is input/output?
- What are constraints?
- What are edge cases?

**Step 2: Brute Force**
- Think simplest solution first
- What's the time complexity?

**Step 3: Optimize**
- Can we avoid redundant work?
- Can we use better data structure?
- Can we sort/preprocess?

**Step 4: Code**
- Start with helper functions
- Handle edge cases first
- Test with examples

**Step 5: Verify**
- Dry run with examples
- Check edge cases
- Analyze complexity

### 5. **Debugging Tips**
- Print intermediate states
- Use small test cases first
- Check boundary conditions (0, 1, n-1, n)
- Verify loop conditions (< vs <=)

---

## Practice Strategy

### Week 1: Foundations
- Master binary search variations
- Practice two pointers technique
- Understand recursion basics

### Week 2: Sliding Window
- Fixed size windows
- Variable size windows
- Window with constraints

### Week 3: Advanced Topics
- Backtracking patterns
- Complex state management
- Optimization techniques

### Week 4: Integration
- Mix multiple techniques
- Time-constrained practice
- Mock interviews

---

## Additional Resources

### Related LeetCode Problems

**Binary Search:**
- 704. Binary Search
- 33. Search in Rotated Sorted Array
- 153. Find Minimum in Rotated Sorted Array

**Sliding Window:**
- 209. Minimum Size Subarray Sum
- 424. Longest Repeating Character Replacement
- 76. Minimum Window Substring

**Backtracking:**
- 46. Permutations
- 78. Subsets
- 39. Combination Sum

**Two Pointers:**
- 15. 3Sum
- 11. Container With Most Water
- 42. Trapping Rain Water

---

## Interview Tips

### What Interviewers Look For

1. **Problem Understanding**
   - Ask clarifying questions
   - Discuss constraints
   - Talk about edge cases

2. **Communication**
   - Explain your thought process
   - Discuss tradeoffs
   - Mention multiple approaches

3. **Code Quality**
   - Clean, readable code
   - Meaningful variable names
   - Proper error handling

4. **Testing**
   - Walk through examples
   - Test edge cases
   - Verify complexity

### Common Mistakes to Avoid

❌ Jumping to code without planning
❌ Not considering edge cases
❌ Silent coding
❌ Getting stuck without asking for help
❌ Not analyzing time/space complexity
❌ Ignoring simpler solutions

✅ Think out loud
✅ Start with brute force
✅ Optimize iteratively
✅ Write clean, tested code
✅ Explain your reasoning

---

## Complexity Cheat Sheet

| Operation | Array | Linked List | Hash Table | Binary Search Tree |
|-----------|-------|-------------|------------|-------------------|
| Access | O(1) | O(n) | - | O(log n) avg |
| Search | O(n) | O(n) | O(1) avg | O(log n) avg |
| Insert | O(n) | O(1)* | O(1) avg | O(log n) avg |
| Delete | O(n) | O(1)* | O(1) avg | O(log n) avg |

*at known position

### String Operations (C++)
```cpp
string s = "hello";
s.length()          // O(1)
s[i]                // O(1)
s.substr(i, len)    // O(len)
s.find(ch)          // O(n)
s + other           // O(n + m)
s.push_back(ch)     // O(1) amortized
```

### Vector Operations (C++)
```cpp
vector<int> v;
v.push_back(x)      // O(1) amortized
v.pop_back()        // O(1)
v.insert(it, x)     // O(n)
v.erase(it)         // O(n)
sort(v.begin(), v.end())  // O(n log n)
```

---

## Final Notes

**Remember:** 
- Practice consistently (daily is better than weekly)
- Understand patterns, don't memorize solutions
- Explain your code to others (or rubber duck!)
- Time yourself to build interview stamina
- Review mistakes and learn from them

**Growth Mindset:**
- Stuck? That's where learning happens
- Wrong answer? Analyze why
- Slow? Speed comes with practice
- Compare with your past self, not others

---
