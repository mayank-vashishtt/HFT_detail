# 3Sum Problem - Complete Explanation

## Problem Statement

Given an integer array `nums`, return all the triplets `[nums[i], nums[j], nums[k]]` such that:
- `i != j`, `i != k`, and `j != k`
- `nums[i] + nums[j] + nums[k] == 0`

**Important:** The solution set must not contain duplicate triplets.

### Example
```
Input: nums = [-1, 0, 1, 2, -1, -4]
Output: [[-1, -1, 2], [-1, 0, 1]]
```

---

## Intuition

### Why is this problem tricky?

1. **Finding three numbers** - We need to find combinations of 3 numbers, not just 2
2. **Avoiding duplicates** - The same triplet shouldn't appear multiple times
3. **Efficiency matters** - A brute force O(n³) solution with three nested loops is too slow

### The Key Insight

The brilliant insight is to **reduce this to a 2Sum problem**:
- Fix one number (`nums[i]`)
- Find two other numbers that sum to `-nums[i]`
- This transforms 3Sum into multiple 2Sum problems!

### Why Sort First?

Sorting enables two powerful techniques:
1. **Two-pointer approach** - Efficiently find pairs that sum to a target
2. **Skip duplicates easily** - Adjacent duplicates can be skipped in O(1) time

---

## Algorithm Breakdown

### Step 1: Sort the Array
```cpp
sort(nums.begin(), nums.end());
// Example: [-4, -1, -1, 0, 1, 2]
```

**Time:** O(n log n)

### Step 2: Fix First Element & Apply Two Pointers

For each element at index `i`:
- **First element:** `nums[i]` (fixed)
- **Second element:** `nums[left]` starting from `i+1`
- **Third element:** `nums[right]` starting from end

```
Array: [-4, -1, -1, 0, 1, 2]
         i   L           R
```

### Step 3: Two Pointer Logic

Calculate `sum = nums[i] + nums[left] + nums[right]`:

**Case 1: sum == 0** ✓
- Found a valid triplet!
- Add to result
- **Move both pointers** while skipping duplicates

**Case 2: sum > 0**
- Too large, need smaller numbers
- Move `right--` (towards smaller values)

**Case 3: sum < 0**
- Too small, need larger numbers
- Move `left++` (towards larger values)

---

## The Duplicate Handling Block (Your Doubt!)

```cpp
int lv = nums[left], rv = nums[right];
while (left < right && nums[left] == lv) left++;
while (left < right && nums[right] == rv) right--;
```

### Why do we need this?

After finding a valid triplet, we must **skip all duplicates** to avoid duplicate results.

### Visual Example

```
Array: [-2, 0, 0, 0, 0, 2]
         i  L1 L2 L3 L4 R

When we find: [-2, 0, 2] at positions [i, L1, R]
```

**Without duplicate skipping:**
- Next iteration: `[-2, 0, 2]` again (using L2 and R)
- Next iteration: `[-2, 0, 2]` again (using L3 and R)
- Result: Multiple duplicate triplets ❌

**With duplicate skipping:**
```cpp
lv = 0  // Store the value at left
rv = 2  // Store the value at right

// Skip all 0s on the left side
while (left < right && nums[left] == 0) left++;
// Now left points past all the 0s

// Skip all 2s on the right side  
while (left < right && nums[right] == 2) right--;
// Now right points past all the 2s
```

After this, `left` and `right` are positioned at **new, different values**, ensuring no duplicate triplets.

### Why check `left < right`?

To prevent the pointers from crossing over, which would mean:
- We've exhausted all possibilities for this fixed `i`
- Time to move to the next `i`

---

## Complete Code Walkthrough

```cpp
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        vector<vector<int>> ans; 
        sort(nums.begin(), nums.end());
        int n = nums.size();

        // Fix the first element
        for(int i = 0; i < n; i++) {
            
            // Skip duplicate first elements
            // [-4, -1, -1, 0, 1, 2]
            //      i1  i2  <- Skip i2 because nums[i1] == nums[i2]
            if(i > 0 && nums[i] == nums[i-1]) continue;

            int left = i + 1;      // Start of remaining array
            int right = n - 1;     // End of array

            // Two pointer approach for 2Sum
            while(left < right) {
                int sum = nums[i] + nums[left] + nums[right];

                if(sum == 0) {
                    // Found a valid triplet!
                    ans.push_back({nums[i], nums[left], nums[right]});

                    // CRITICAL: Skip duplicates for both pointers
                    int lv = nums[left];
                    int rv = nums[right];
                    
                    // Move past all duplicate left values
                    while (left < right && nums[left] == lv) left++;
                    
                    // Move past all duplicate right values
                    while (left < right && nums[right] == rv) right--;
                }
                else if(sum > 0) {
                    // Sum too large, need smaller right value
                    right--;
                }
                else {
                    // Sum too small, need larger left value
                    left++;
                }
            }
        }

        return ans;
    }
};
```

---

## Dry Run Example

**Input:** `nums = [-1, 0, 1, 2, -1, -4]`

### After Sorting:
```
[-4, -1, -1, 0, 1, 2]
```

### Iteration 1: i = 0, nums[i] = -4
```
[-4, -1, -1, 0, 1, 2]
  i   L           R

sum = -4 + (-1) + 2 = -3 < 0  → left++

[-4, -1, -1, 0, 1, 2]
  i       L       R

sum = -4 + (-1) + 2 = -3 < 0  → left++

[-4, -1, -1, 0, 1, 2]
  i           L   R

sum = -4 + 0 + 2 = -2 < 0     → left++

[-4, -1, -1, 0, 1, 2]
  i               L R

sum = -4 + 1 + 2 = -1 < 0     → left++

left >= right, exit while loop
```

### Iteration 2: i = 1, nums[i] = -1
```
[-4, -1, -1, 0, 1, 2]
      i   L       R

sum = -1 + (-1) + 2 = 0 ✓     → Found triplet [-1, -1, 2]

Skip duplicates:
- lv = -1, skip nums[L] while it's -1
- rv = 2, skip nums[R] while it's 2

[-4, -1, -1, 0, 1, 2]
      i       L R

sum = -1 + 0 + 1 = 0 ✓        → Found triplet [-1, 0, 1]

Skip duplicates and exit
```

### Iteration 3: i = 2, nums[i] = -1
```
Skip because nums[2] == nums[1] (duplicate)
```

### Iterations 4, 5: Similar process, no new triplets found

**Final Answer:** `[[-1, -1, 2], [-1, 0, 1]]`

---

## Complexity Analysis

### Time Complexity: **O(n²)**
- Sorting: O(n log n)
- Outer loop: O(n)
- Inner while loop: O(n) for each iteration
- Total: O(n log n) + O(n²) = **O(n²)**

### Space Complexity: **O(1)** or **O(n)**
- O(1) if we don't count output space
- O(n) if we count the space for sorting (depends on sort implementation)

---

## Key Takeaways

1. **Sort first** - Enables two-pointer technique and easy duplicate skipping
2. **Reduce to 2Sum** - Fix one element, find two others
3. **Skip duplicates carefully** - Both for the fixed element and the two-pointer pairs
4. **Two pointers are powerful** - Move towards the target sum efficiently

## Common Mistakes to Avoid

❌ Forgetting to skip duplicates → Duplicate triplets in result  
❌ Not checking `left < right` → Pointer crossover bugs  
❌ Skipping duplicates incorrectly → Missing valid triplets  
❌ Moving only one pointer after finding a triplet → Duplicate results

---

## Practice Variations

Once you master this:
- **4Sum** - Similar approach with an extra loop
- **3Sum Closest** - Find triplet closest to a target
- **3Sum Smaller** - Count triplets with sum less than target