# Count Number of Subarrays With Given Sum (LeetCode-style)

## Problem statement

Given an integer array `nums` and an integer `goal`, return the number of non-empty subarrays whose sum equals `goal`.

Example: `nums = [1,0,1,0,1]`, `goal = 2` → answer = 4 (subarrays: `[1,0,1]` at indices, etc.)

---

## Intuition & Approach (Prefix-sum + HashMap)

We want to count subarrays `nums[l..r]` such that sum(`nums[l..r]`) = `goal`.

If we maintain the prefix-sum array `pref` where `pref[i]` = sum of first `i` elements (0-based: `pref[0]=0`, `pref[1]=nums[0]`, ...), then the sum of `nums[l..r]` equals `pref[r+1] - pref[l]`.

We want `pref[r+1] - pref[l] == goal` → `pref[l] == pref[r+1] - goal`.

As we iterate through the array and compute current prefix `cur = pref[r+1]`, the number of `l` that satisfy the equation equals how many times value `cur - goal` has appeared as a prefix so far. So keep a frequency map `freq` of prefix sums we've seen.

Algorithm (one pass):

1. Initialize `freq[0] = 1` (empty prefix).
2. `cur = 0, ans = 0`.
3. For each `x` in `nums`:

   * `cur += x`
   * `need = cur - goal`
   * If `freq` contains `need`, add `freq[need]` to `ans`.
   * Increment `freq[cur]`.
4. Return `ans`.

Why it works: every time `need` appeared as a prefix before index `r`, it corresponds to a starting index `l` where the subarray sum to `r` equals `goal`.

Time complexity: O(n) average (hashmap operations). Space complexity: O(n) to store prefix counts.

---

## Clean C++ Implementation

```cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    int numSubarraysWithSum(vector<int>& nums, int goal) {
        unordered_map<int, int> freq;
        freq[0] = 1;           // one way to have prefix sum 0 (empty prefix)
        int cur = 0;
        int ans = 0;
        for (int x : nums) {
            cur += x;                      // current prefix sum
            int need = cur - goal;         // earlier prefix required
            if (auto it = freq.find(need); it != freq.end()) {
                ans += it->second;
            }
            ++freq[cur];
        }
        return ans;
    }
};

// Usage example (not part of class):
// vector<int> nums = {1,0,1,0,1}; int goal = 2;
// Solution s; cout << s.numSubarraysWithSum(nums, goal) << "\n"; // prints 4
```

---

## Walkthrough Example (step-by-step)

`nums = [1, 0, 1, 0, 1], goal = 2`

* Start: `freq = {0:1}`, `cur=0`, `ans=0`.
* After x=1: `cur=1`, `need= -1` (not present), `ans=0`, `freq={0:1,1:1}`.
* After x=0: `cur=1`, `need=-1` (not present), `ans=0`, `freq={0:1,1:2}`.
* After x=1: `cur=2`, `need=0` (present freq 1), `ans=1`, `freq={0:1,1:2,2:1}`.
* After x=0: `cur=2`, `need=0` (present freq 1), `ans=2`, `freq={0:1,1:2,2:2}`.
* After x=1: `cur=3`, `need=1` (present freq 2), `ans=4`, `freq={0:1,1:2,2:2,3:1}`.

Answer = 4.

---

## Variants & Similar Problems (with approach + code)

### 1) Subarray Sum Equals K (general integers)

**Problem:** Given integer array `nums` (may contain negatives), count subarrays with sum = `k`.

**Approach:** Exactly the same prefix-sum + hashmap method. Works with negatives because we don't rely on monotonicity.

**C++:**

```cpp
int subarraySumEqualsK(vector<int>& nums, int k) {
    unordered_map<int,int> freq;
    freq[0] = 1;
    int cur = 0, ans = 0;
    for (int x : nums) {
        cur += x;
        int need = cur - k;
        if (auto it = freq.find(need); it != freq.end()) ans += it->second;
        ++freq[cur];
    }
    return ans;
}
```

**Complexities:** O(n) time, O(n) space.

---

### 2) Number of Subarrays with Sum at Most K (non-negative array)

**Problem:** Given non-negative integers `nums`, count subarrays with sum ≤ `K`.

**Approach:** Two-pointers (sliding window). For non-negative arrays, you can expand right pointer and move left while sum > K. The number of subarrays ending at right with sum ≤ K equals `(right - left + 1)`.

**C++:**

```cpp
long long atMostK(const vector<int>& nums, int K) {
    if (K < 0) return 0; // if K negative and nums non-negative
    long long ans = 0;
    int left = 0;
    long long cur = 0;
    for (int right = 0; right < (int)nums.size(); ++right) {
        cur += nums[right];
        while (cur > K && left <= right) {
            cur -= nums[left++];
        }
        ans += (right - left + 1);
    }
    return ans;
}

// To get count of subarrays with sum exactly K for non-negative array:
long long exactlyK(const vector<int>& nums, int K) {
    return atMostK(nums, K) - atMostK(nums, K-1);
}
```

**Note:** This approach requires non-negative integers.

---

### 3) Binary Array — Number of Subarrays with Sum = S (special-case fast method)

**Problem:** `nums` contains only 0s and 1s. Count subarrays with sum = `S`.

**Approach (positions of 1s):** Store indices of ones. For each block of S consecutive ones (i-th one ... (i+S-1)-th one), the number of valid subarrays that have exactly those S ones equals:
`(#zeros before first one + 1) * (#zeros after last one + 1)`.
Handle S = 0 separately: count subarrays consisting of only zeros using n*(n+1)/2 formula for zero blocks.

**C++:**

```cpp
long long numSubarraysWithSumBinary(const vector<int>& nums, int S) {
    vector<int> ones;
    int n = nums.size();
    for (int i = 0; i < n; ++i) if (nums[i] == 1) ones.push_back(i);
    if (S == 0) {
        long long ans = 0;
        long long len = 0;
        for (int x : nums) {
            if (x == 0) ++len; else { ans += len*(len+1)/2; len = 0; }
        }
        ans += len*(len+1)/2;
        return ans;
    }
    if ((int)ones.size() < S) return 0;
    long long ans = 0;
    for (int i = 0; i + S - 1 < (int)ones.size(); ++i) {
        int leftIdx = ones[i];
        int rightIdx = ones[i + S - 1];
        int prevOne = (i == 0 ? -1 : ones[i-1]);
        int nextOne = (i + S - 1 == (int)ones.size() - 1 ? n : ones[i + S]);
        long long leftChoices = leftIdx - prevOne;    // zeros between prevOne and leftIdx
        long long rightChoices = nextOne - rightIdx; // zeros between rightIdx and nextOne
        ans += leftChoices * rightChoices;
    }
    return ans;
}
```

**Complexity:** O(n) time, O(m) space (m = number of ones).

---

## Practice Problems (recommended)

1. **LeetCode 560 — Subarray Sum Equals K** (general integers) — use prefix-sum map.
2. **LeetCode 930 — Binary Subarrays With Sum** — variety of solutions including positions-of-ones or prefix map.
3. **Count subarrays with sum at most K** (sliding window) — for non-negative arrays.
4. **Count subarrays with sum exactly K where numbers are small (e.g., 0/1/2)** — try both hashmap and two-pointer variants; measure which is faster.

---

## Complexity Summary

* Prefix-sum + hashmap: O(n) time average, O(n) space.
* Sliding-window (non-negative): O(n) time, O(1) extra space.
* Binary positions method: O(n) time, O(m) space.

---
