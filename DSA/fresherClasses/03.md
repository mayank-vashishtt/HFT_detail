# ğŸš€ Complete DSA Guide: From Basics to Advanced

## Table of Contents
1. [Binary Search](#1-binary-search)
2. [Two Sum Problem](#2-two-sum-problem)
3. [Move Zeroes to End](#3-move-zeroes-to-end)
4. [Palindrome Number](#4-palindrome-number)

---

## 1. Binary Search

### ğŸ¯ Why Binary Search?

**The Problem with Linear Search:**
- Searching in an array of 1 million elements? Linear search checks **every single element** = O(n)
- Binary Search? Only needs **~20 comparisons** = O(log n)

**The Magic Formula:**
```
Linear Search: 1,000,000 steps
Binary Search: logâ‚‚(1,000,000) â‰ˆ 20 steps
```

### ğŸ”‘ Core Requirement: **SORTED ARRAY**

Binary search **ONLY** works on sorted arrays. Why?

**Think of a dictionary:**
- Looking for "Zebra"? You open the book near the end (because Z comes late)
- Book says "Tiger"? You know Zebra is **after** this, so search right side
- Book says "Wolf"? Zebra is **before** this, search left side

This **elimination** only works because letters are **sorted**!

---

### ğŸ“š The Intuition

Imagine guessing a number between 1-100:
- **Bad Strategy:** Try 1, 2, 3, 4... (Linear Search - O(n))
- **Smart Strategy:** Try 50
  - Too high? Search 1-49
  - Too low? Search 51-100
  - **Cut the problem in HALF every time!** (Binary Search - O(log n))

---

### ğŸ’» Implementation Breakdown

```cpp
bool binarySearch(int arr[], int target, int size) {
    int left = 0;           // Start of search space
    int right = size - 1;   // End of search space
    
    while(left <= right) {  // While search space exists
        int mid = (left + right) / 2;  // Middle element
        
        if(arr[mid] == target) {
            return true;  // Found it!
        }
        else if(arr[mid] > target) {
            right = mid - 1;  // Target is in LEFT half
        }
        else {
            left = mid + 1;   // Target is in RIGHT half
        }
    }
    
    return false;  // Not found
}
```

### ğŸ¬ Step-by-Step Example

**Array:** `[1, 4, 7, 9, 10, 21, 23, 45, 54, 68]`  
**Target:** `23`

```
Step 1: left=0, right=9, mid=4
        arr[4] = 10
        10 < 23 â†’ search RIGHT
        [1, 4, 7, 9, 10, | 21, 23, 45, 54, 68]
                          â†‘ new left

Step 2: left=5, right=9, mid=7
        arr[7] = 45
        45 > 23 â†’ search LEFT
        [21, 23, 45, | 54, 68]
             â†‘ new right

Step 3: left=5, right=6, mid=5
        arr[5] = 21
        21 < 23 â†’ search RIGHT
        [21, | 23]
              â†‘ new left

Step 4: left=6, right=6, mid=6
        arr[6] = 23
        FOUND! âœ…
```

---

### âš ï¸ Common Pitfall: Integer Overflow

```cpp
// âŒ DANGEROUS for large values
int mid = (left + right) / 2;  // Can overflow!

// âœ… SAFE
int mid = left + (right - left) / 2;
```

**Why?** If `left = 2,000,000,000` and `right = 2,000,000,000`:
- `left + right = 4,000,000,000` â†’ **Overflow!** (exceeds int max)
- `left + (right - left)/2` â†’ Safe calculation

---

### ğŸ§  Advanced Concepts

#### Finding First/Last Occurrence

**Problem:** Array = `[1, 2, 2, 2, 2, 3, 4]`, find **first** occurrence of `2`

```cpp
int findFirst(int arr[], int target, int size) {
    int left = 0, right = size - 1;
    int result = -1;  // Store result
    
    while(left <= right) {
        int mid = left + (right - left) / 2;
        
        if(arr[mid] == target) {
            result = mid;        // Found one, but keep searching LEFT
            right = mid - 1;     // Maybe there's an earlier one
        }
        else if(arr[mid] < target) {
            left = mid + 1;
        }
        else {
            right = mid - 1;
        }
    }
    
    return result;
}
```

#### Finding Insertion Position

**Problem:** Where should `5` be inserted in `[1, 3, 7, 9]` to keep it sorted?

```cpp
int searchInsert(int arr[], int target, int size) {
    int left = 0, right = size - 1;
    
    while(left <= right) {
        int mid = left + (right - left) / 2;
        
        if(arr[mid] == target) return mid;
        else if(arr[mid] < target) left = mid + 1;
        else right = mid - 1;
    }
    
    return left;  // Insertion position
}
```

---

### ğŸ“Š Time & Space Complexity

| Operation | Time | Space |
|-----------|------|-------|
| Binary Search | O(log n) | O(1) |
| Linear Search | O(n) | O(1) |

**Real Impact:**
- **1 million elements:** Binary = 20 steps, Linear = 1,000,000 steps
- **1 billion elements:** Binary = 30 steps, Linear = 1,000,000,000 steps

---

## 2. Two Sum Problem

### ğŸ¯ Problem Statement

Given an array and a target, find **two numbers** that add up to the target.

**Example:**
```
nums = [2, 7, 11, 15], target = 9
Output: [0, 1]  (because nums[0] + nums[1] = 2 + 7 = 9)
```

---

### ğŸ§  Intuition (Three Approaches)

#### Approach 1: Brute Force (Beginner)

**"Check every possible pair"**

```cpp
// O(nÂ²) Time, O(1) Space
vector<int> twoSum(vector<int>& nums, int target) {
    for(int i = 0; i < nums.size(); i++) {
        for(int j = i + 1; j < nums.size(); j++) {
            if(nums[i] + nums[j] == target) {
                return {i, j};
            }
        }
    }
    return {};
}
```

**Why slow?** For 1000 elements = 1000 Ã— 999 = ~1 million comparisons!

---

#### Approach 2: Hash Map (Optimal)

**"Remember what you've seen"**

**The Key Insight:**
- If you need `target = 9` and you see `2`
- You immediately know you need `7` (because 9 - 2 = 7)
- Have you seen `7` before? Check your memory (hash map)!

```cpp
// O(n) Time, O(n) Space
vector<int> twoSum(vector<int>& nums, int target) {
    unordered_map<int, int> seen;  // {value : index}
    
    for(int i = 0; i < nums.size(); i++) {
        int complement = target - nums[i];
        
        // Have we seen the complement before?
        if(seen.count(complement)) {
            return {seen[complement], i};
        }
        
        // Remember this number and its index
        seen[nums[i]] = i;
    }
    
    return {};
}
```

**Visual Example:**
```
nums = [2, 7, 11, 15], target = 9

Step 1: i=0, nums[0]=2
        complement = 9-2 = 7
        seen = {}
        7 not in seen â†’ Add 2
        seen = {2:0}

Step 2: i=1, nums[1]=7
        complement = 9-7 = 2
        seen = {2:0}
        2 IS in seen! â†’ Return [0, 1] âœ…
```

---

#### Approach 3: Two Pointers (If Sorted)

**"Squeeze from both ends"**

```cpp
// O(n log n) Time (for sorting), O(1) Space
vector<int> twoSum(vector<int>& nums, int target) {
    // Create pairs of {value, original_index}
    vector<pair<int,int>> arr;
    for(int i = 0; i < nums.size(); i++) {
        arr.push_back({nums[i], i});
    }
    
    // Sort by value
    sort(arr.begin(), arr.end());
    
    int left = 0, right = nums.size() - 1;
    
    while(left < right) {
        int sum = arr[left].first + arr[right].first;
        
        if(sum == target) {
            return {arr[left].second, arr[right].second};
        }
        else if(sum < target) {
            left++;   // Need bigger sum
        }
        else {
            right--;  // Need smaller sum
        }
    }
    
    return {};
}
```

---

### ğŸ“Š Comparison

| Approach | Time | Space | Best For |
|----------|------|-------|----------|
| Brute Force | O(nÂ²) | O(1) | Small arrays |
| Hash Map | O(n) | O(n) | **Best overall** |
| Two Pointers | O(n log n) | O(1) | Space-constrained |

---

## 3. Move Zeroes to End

### ğŸ¯ Problem

Move all zeroes to the end while maintaining the relative order of non-zero elements.

**Example:**
```
Input:  [0, 1, 0, 3, 12]
Output: [1, 3, 12, 0, 0]
```

---

### ğŸ§  Intuition: "Two Pointer Technique"

**Think of it like organizing a queue:**
- `count` = Position where next non-zero element should go
- `i` = Current element we're examining

**The Strategy:**
1. Scan through array
2. When you find a non-zero, place it at position `count`
3. Increment `count` (next non-zero goes here)
4. After scanning, fill remaining positions with zeros

---

### ğŸ’» Implementation

```cpp
void moveZeroes(vector<int>& nums) {
    int count = 0;  // Position for next non-zero
    
    // Step 1: Move all non-zero elements to front
    for(int i = 0; i < nums.size(); i++) {
        if(nums[i] != 0) {
            nums[count] = nums[i];
            count++;
        }
    }
    
    // Step 2: Fill remaining positions with zeros
    while(count < nums.size()) {
        nums[count] = 0;
        count++;
    }
}
```

---

### ğŸ¬ Visual Walkthrough

```
Input: [0, 1, 0, 3, 12]

count=0, i=0: nums[0]=0 â†’ Skip (it's zero)
[0, 1, 0, 3, 12]
 â†‘
count

count=0, i=1: nums[1]=1 â†’ Place at count
[1, 1, 0, 3, 12]
 â†‘
count (now count=1)

count=1, i=2: nums[2]=0 â†’ Skip
[1, 1, 0, 3, 12]
    â†‘
   count

count=1, i=3: nums[3]=3 â†’ Place at count
[1, 3, 0, 3, 12]
    â†‘
   count (now count=2)

count=2, i=4: nums[4]=12 â†’ Place at count
[1, 3, 12, 3, 12]
       â†‘
      count (now count=3)

Now fill zeros from count=3 to end:
[1, 3, 12, 0, 0] âœ…
```

---

### ğŸš€ Optimized: Swap Method

**Even more elegant - swap as you go:**

```cpp
void moveZeroes(vector<int>& nums) {
    int nonZeroPos = 0;
    
    // Move non-zeros forward and swap
    for(int i = 0; i < nums.size(); i++) {
        if(nums[i] != 0) {
            swap(nums[nonZeroPos], nums[i]);
            nonZeroPos++;
        }
    }
}
```

**Why better?** Single pass, simpler logic!

---

### ğŸ“Š Complexity

| Approach | Time | Space |
|----------|------|-------|
| Two-pass | O(n) | O(1) |
| Swap | O(n) | O(1) |

---

## 4. Palindrome Number

### ğŸ¯ Problem

Check if a number reads the same forwards and backwards.

**Examples:**
```
121 â†’ true  (reads as 121 both ways)
-121 â†’ false (negative numbers aren't palindromes)
10 â†’ false  (reads as 01 backwards, which is 1)
```

---

### ğŸ§  Intuition

**Like reading a word backwards:**
- "RACECAR" backwards is "RACECAR" âœ…
- "HELLO" backwards is "OLLEH" âŒ

**For numbers:**
- Extract digits from right to left
- Build the reversed number
- Compare with original

---

### ğŸ’» Implementation

```cpp
bool isPalindrome(int x) {
    // Negative numbers are not palindromes
    if(x < 0) return false;
    
    long rev = 0;      // Reversed number
    int original = x;  // Keep original for comparison
    
    // Reverse the number
    while(x > 0) {
        int lastDigit = x % 10;     // Get last digit
        rev = (rev * 10) + lastDigit;  // Add to reversed
        x = x / 10;                 // Remove last digit
    }
    
    return (rev == original);
}
```

---

### ğŸ¬ Step-by-Step Example

**Input:** `x = 121`

```
Iteration 1:
  x = 121, rev = 0
  lastDigit = 121 % 10 = 1
  rev = (0 * 10) + 1 = 1
  x = 121 / 10 = 12

Iteration 2:
  x = 12, rev = 1
  lastDigit = 12 % 10 = 2
  rev = (1 * 10) + 2 = 12
  x = 12 / 10 = 1

Iteration 3:
  x = 1, rev = 12
  lastDigit = 1 % 10 = 1
  rev = (12 * 10) + 1 = 121
  x = 1 / 10 = 0

Loop ends (x = 0)
rev = 121, original = 121
121 == 121 â†’ true âœ…
```

---

### âš ï¸ Edge Cases

```cpp
// Negative numbers
-121 â†’ false  (not palindrome by definition)

// Numbers ending in 0
10 â†’ false    (reversed is 01 = 1, not equal)
100 â†’ false

// Single digit
5 â†’ true      (trivially palindrome)

// Overflow concern
1234567899 â†’ Use 'long' for rev to prevent overflow
```

---

### ğŸš€ Optimized: Half-Reversal

**Key insight:** Only need to reverse half!

```cpp
bool isPalindrome(int x) {
    // Negative or ends with 0 (except 0 itself)
    if(x < 0 || (x % 10 == 0 && x != 0)) {
        return false;
    }
    
    int reversed = 0;
    
    // Reverse half of the number
    while(x > reversed) {
        reversed = reversed * 10 + x % 10;
        x /= 10;
    }
    
    // For odd length: x == reversed/10
    // For even length: x == reversed
    return x == reversed || x == reversed / 10;
}
```

**Example for 12321:**
```
After half reversal:
x = 12, reversed = 123
Check: 12 == 123/10 â†’ 12 == 12 âœ…
```

---

### ğŸ“Š Complexity

| Approach | Time | Space |
|----------|------|-------|
| Full Reversal | O(log n) | O(1) |
| Half Reversal | O(log n) | O(1) |

**Note:** O(log n) because we process each digit once, and number of digits = logâ‚â‚€(n)

---

## ğŸ“ Key Takeaways

### Binary Search
âœ… Requires **sorted** array  
âœ… O(log n) time - incredibly fast  
âœ… Master the mid calculation to avoid overflow  

### Two Sum
âœ… Hash map approach is optimal: O(n) time  
âœ… Trade space for time  
âœ… Two pointers works on sorted arrays  

### Move Zeroes
âœ… Two-pointer technique shines here  
âœ… Maintain relative order  
âœ… In-place operation saves space  

### Palindrome
âœ… Extract and reverse digits  
âœ… Watch for negative numbers and trailing zeros  
âœ… Half-reversal optimization is elegant  

---

## ğŸ’¡ Pro Tips

1. **Always test edge cases:**
   - Empty array
   - Single element
   - All same elements
   - Negative numbers

2. **Draw it out:**
   - Visualize with small examples
   - Trace through algorithm step-by-step

3. **Think about constraints:**
   - Can I modify the input?
   - Is extra space allowed?
   - What's the input size?

4. **Optimization hierarchy:**
   - First make it work (correctness)
   - Then make it right (clean code)
   - Finally make it fast (optimize)

---

## ğŸ¯ Next Steps

- Practice these problems on LeetCode
- Time yourself solving variations
- Explain solutions to others (best way to learn!)
- Combine techniques (e.g., binary search + two pointers)

Happy Coding! ğŸš€