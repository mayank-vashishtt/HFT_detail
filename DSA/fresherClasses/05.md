# DSA Notes - Binary Search & Array Problems

## Table of Contents
1. [Lower Bound in Binary Search](#lower-bound)
2. [Upper Bound in Binary Search](#upper-bound)
3. [3Sum Problem](#3sum)
4. [Find Pivot Index](#pivot-index)
5. [Running Sum of 1D Array](#running-sum)

---

## 1. Lower Bound in Binary Search {#lower-bound}

### Intuition
Lower bound finds the **first position** where we can insert a target value while maintaining sorted order. It returns an iterator/index to the first element that is **NOT LESS than** (i.e., greater than or equal to) the target value.

**Key Points:**
- If target exists: returns first occurrence
- If target doesn't exist: returns position where it should be inserted
- Always returns a valid position (can be end of array)

### Visual Example
```
Array: [1, 2, 4, 4, 4, 6, 7]
Target: 4

Lower Bound → Index 2 (first occurrence of 4)
```

```
Array: [1, 2, 4, 4, 4, 6, 7]
Target: 5

Lower Bound → Index 5 (position where 5 should be inserted)
```

### C++ Implementation

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

// Method 1: Using STL
int lowerBoundSTL(vector<int>& arr, int target) {
    auto it = lower_bound(arr.begin(), arr.end(), target);
    return it - arr.begin(); // Returns index
}

// Method 2: Manual Implementation
int lowerBoundManual(vector<int>& arr, int target) {
    int left = 0, right = arr.size();
    
    while (left < right) {
        int mid = left + (right - left) / 2;
        
        if (arr[mid] < target) {
            left = mid + 1;  // Search right half
        } else {
            right = mid;     // Potential answer, search left
        }
    }
    
    return left;
}

int main() {
    vector<int> arr = {1, 2, 4, 4, 4, 6, 7};
    
    cout << "Lower bound of 4: " << lowerBoundManual(arr, 4) << endl;  // Output: 2
    cout << "Lower bound of 5: " << lowerBoundManual(arr, 5) << endl;  // Output: 5
    cout << "Lower bound of 0: " << lowerBoundManual(arr, 0) << endl;  // Output: 0
    
    return 0;
}
```

### Time Complexity: O(log n)
### Space Complexity: O(1)

---

## 2. Upper Bound in Binary Search {#upper-bound}

### Intuition
Upper bound finds the position of the **first element GREATER than** the target value. It's useful when you want to find where to insert a value such that it comes after all equal elements.

**Key Points:**
- Returns position of first element > target
- If all elements ≤ target: returns end position
- Always maintains sorted order after insertion

### Visual Example
```
Array: [1, 2, 4, 4, 4, 6, 7]
Target: 4

Upper Bound → Index 5 (first element > 4, which is 6)
```

```
Array: [1, 2, 4, 4, 4, 6, 7]
Target: 5

Upper Bound → Index 5 (first element > 5, which is 6)
```

### C++ Implementation

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

// Method 1: Using STL
int upperBoundSTL(vector<int>& arr, int target) {
    auto it = upper_bound(arr.begin(), arr.end(), target);
    return it - arr.begin();
}

// Method 2: Manual Implementation
int upperBoundManual(vector<int>& arr, int target) {
    int left = 0, right = arr.size();
    
    while (left < right) {
        int mid = left + (right - left) / 2;
        
        if (arr[mid] <= target) {
            left = mid + 1;  // Search right half
        } else {
            right = mid;     // Potential answer, search left
        }
    }
    
    return left;
}

int main() {
    vector<int> arr = {1, 2, 4, 4, 4, 6, 7};
    
    cout << "Upper bound of 4: " << upperBoundManual(arr, 4) << endl;  // Output: 5
    cout << "Upper bound of 5: " << upperBoundManual(arr, 5) << endl;  // Output: 5
    cout << "Upper bound of 7: " << upperBoundManual(arr, 7) << endl;  // Output: 7
    
    return 0;
}
```

### Time Complexity: O(log n)
### Space Complexity: O(1)

### Comparison: Lower Bound vs Upper Bound

| Feature | Lower Bound | Upper Bound |
|---------|-------------|-------------|
| Returns | First element ≥ target | First element > target |
| If target exists | First occurrence | Position after last occurrence |
| Condition | arr[mid] < target | arr[mid] ≤ target |

---

## 3. 3Sum Problem {#3sum}

### Problem Statement
Given an integer array nums, return all unique triplets `[nums[i], nums[j], nums[k]]` such that `i != j`, `i != k`, and `j != k`, and `nums[i] + nums[j] + nums[k] == 0`.

### Intuition
The key insight is to:
1. **Sort the array** first
2. **Fix one element** and use two-pointer technique for remaining two
3. **Skip duplicates** to avoid duplicate triplets

**Why sort?**
- Enables two-pointer technique
- Makes duplicate detection easy
- Converts 3Sum to 2Sum problem

### Visual Example
```
Input: nums = [-1, 0, 1, 2, -1, -4]
After sorting: [-4, -1, -1, 0, 1, 2]

Fix -1 at index 1:
  [-4, -1, -1, 0, 1, 2]
        ^   L        R
  
  -1 + (-1) + 2 = 0 ✓
  
Output: [[-1, -1, 2], [-1, 0, 1]]
```

### C++ Implementation

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        vector<vector<int>> result;
        int n = nums.size();
        
        // Step 1: Sort the array
        sort(nums.begin(), nums.end());
        
        // Step 2: Fix first element and find other two
        for (int i = 0; i < n - 2; i++) {
            // Skip duplicates for first element
            if (i > 0 && nums[i] == nums[i - 1]) continue;
            
            // Two pointer approach
            int left = i + 1;
            int right = n - 1;
            int target = -nums[i];
            
            while (left < right) {
                int sum = nums[left] + nums[right];
                
                if (sum == target) {
                    result.push_back({nums[i], nums[left], nums[right]});
                    
                    // Skip duplicates for second element
                    while (left < right && nums[left] == nums[left + 1]) left++;
                    // Skip duplicates for third element
                    while (left < right && nums[right] == nums[right - 1]) right--;
                    
                    left++;
                    right--;
                } else if (sum < target) {
                    left++;  // Need larger sum
                } else {
                    right--; // Need smaller sum
                }
            }
        }
        
        return result;
    }
};

int main() {
    Solution sol;
    vector<int> nums = {-1, 0, 1, 2, -1, -4};
    
    vector<vector<int>> result = sol.threeSum(nums);
    
    cout << "Triplets that sum to 0:" << endl;
    for (auto& triplet : result) {
        cout << "[" << triplet[0] << ", " << triplet[1] << ", " << triplet[2] << "]" << endl;
    }
    
    return 0;
}
```

### Time Complexity: O(n²)
- Sorting: O(n log n)
- Outer loop: O(n)
- Two pointer: O(n)
- Total: O(n log n) + O(n²) = O(n²)

### Space Complexity: O(1) or O(n)
- O(1) if we don't count output array
- O(n) for sorting (depending on implementation)

### Key Points to Remember
- Always sort first
- Skip duplicates at all three positions
- Two-pointer technique reduces one dimension of complexity

---

## 4. Find Pivot Index {#pivot-index}

### Problem Statement
Given an array of integers `nums`, calculate the pivot index of this array. The pivot index is where the sum of all numbers to the left equals the sum of all numbers to the right.

### Intuition
The key insight is:
- **Total Sum = Left Sum + Pivot + Right Sum**
- If pivot exists: **Left Sum = Right Sum**
- Therefore: **Left Sum = (Total Sum - nums[i]) / 2**

**Approach:**
1. Calculate total sum
2. Iterate and maintain left sum
3. Check if: leftSum == totalSum - leftSum - nums[i]

### Visual Example
```
Array: [1, 7, 3, 6, 5, 6]
Index:  0  1  2  3  4  5

At index 3:
Left sum  = 1 + 7 + 3 = 11
Right sum = 5 + 6 = 11

Pivot Index = 3 ✓
```

### C++ Implementation

```cpp
#include <iostream>
#include <vector>
#include <numeric>
using namespace std;

class Solution {
public:
    int pivotIndex(vector<int>& nums) {
        // Calculate total sum
        int totalSum = accumulate(nums.begin(), nums.end(), 0);
        int leftSum = 0;
        
        for (int i = 0; i < nums.size(); i++) {
            // Check if current index is pivot
            // rightSum = totalSum - leftSum - nums[i]
            if (leftSum == totalSum - leftSum - nums[i]) {
                return i;
            }
            
            // Update left sum for next iteration
            leftSum += nums[i];
        }
        
        return -1; // No pivot found
    }
};

// Alternative approach with explicit right sum
class Solution2 {
public:
    int pivotIndex(vector<int>& nums) {
        int totalSum = 0;
        for (int num : nums) totalSum += num;
        
        int leftSum = 0;
        for (int i = 0; i < nums.size(); i++) {
            int rightSum = totalSum - leftSum - nums[i];
            
            if (leftSum == rightSum) {
                return i;
            }
            
            leftSum += nums[i];
        }
        
        return -1;
    }
};

int main() {
    Solution sol;
    
    vector<int> nums1 = {1, 7, 3, 6, 5, 6};
    cout << "Pivot index: " << sol.pivotIndex(nums1) << endl;  // Output: 3
    
    vector<int> nums2 = {1, 2, 3};
    cout << "Pivot index: " << sol.pivotIndex(nums2) << endl;  // Output: -1
    
    vector<int> nums3 = {2, 1, -1};
    cout << "Pivot index: " << sol.pivotIndex(nums3) << endl;  // Output: 0
    
    return 0;
}
```

### Time Complexity: O(n)
- One pass to calculate total sum
- One pass to find pivot

### Space Complexity: O(1)
- Only using variables for sums

### Edge Cases to Consider
1. Empty array → return -1
2. Single element → return 0 (left sum = 0, right sum = 0)
3. Pivot at beginning → left sum = 0
4. Pivot at end → right sum = 0

---

## 5. Running Sum of 1D Array {#running-sum}

### Problem Statement
Given an array `nums`, return the running sum array where `runningSum[i] = sum(nums[0]...nums[i])`.

### Intuition
Running sum (also called prefix sum) is a cumulative sum where each position stores the sum of all previous elements including current.

**Key Insight:**
- `runningSum[i] = runningSum[i-1] + nums[i]`
- Each element depends only on previous element

### Visual Example
```
Input:  [3, 1, 2, 10, 1]

Step by step:
Index 0: 3
Index 1: 3 + 1 = 4
Index 2: 4 + 2 = 6
Index 3: 6 + 10 = 16
Index 4: 16 + 1 = 17

Output: [3, 4, 6, 16, 17]
```

### C++ Implementation

```cpp
#include <iostream>
#include <vector>
using namespace std;

// Method 1: Using extra space
class Solution1 {
public:
    vector<int> runningSum(vector<int>& nums) {
        int n = nums.size();
        vector<int> result(n);
        result[0] = nums[0];
        
        for (int i = 1; i < n; i++) {
            result[i] = result[i - 1] + nums[i];
        }
        
        return result;
    }
};

// Method 2: In-place modification (space optimized)
class Solution2 {
public:
    vector<int>& runningSum(vector<int>& nums) {
        for (int i = 1; i < nums.size(); i++) {
            nums[i] += nums[i - 1];
        }
        
        return nums;
    }
};

// Method 3: Using partial_sum (STL)
#include <numeric>
class Solution3 {
public:
    vector<int> runningSum(vector<int>& nums) {
        vector<int> result(nums.size());
        partial_sum(nums.begin(), nums.end(), result.begin());
        return result;
    }
};

int main() {
    Solution2 sol;
    
    vector<int> nums1 = {3, 1, 2, 10, 1};
    vector<int> result1 = sol.runningSum(nums1);
    
    cout << "Running sum: ";
    for (int num : result1) {
        cout << num << " ";
    }
    cout << endl;  // Output: 3 4 6 16 17
    
    vector<int> nums2 = {1, 2, 3, 4};
    vector<int> result2 = sol.runningSum(nums2);
    
    cout << "Running sum: ";
    for (int num : result2) {
        cout << num << " ";
    }
    cout << endl;  // Output: 1 3 6 10
    
    return 0;
}
```

### Time Complexity: O(n)
- Single pass through array

### Space Complexity: 
- O(n) for Method 1 (extra array)
- O(1) for Method 2 (in-place)

### Applications of Running Sum
1. **Range Sum Queries**: Query sum of elements between indices i and j in O(1)
   - `rangeSum(i, j) = prefixSum[j] - prefixSum[i-1]`
2. **Subarray sum problems**
3. **Finding equilibrium index**
4. **2D prefix sums for matrix problems**

### Practice Problems Using Running Sum
1. Range Sum Query - Immutable (LeetCode 303)
2. Subarray Sum Equals K (LeetCode 560)
3. Contiguous Array (LeetCode 525)

---

## Practice Tips

### For Binary Search Problems:
1. Always check boundary conditions
2. Decide on `[left, right)` or `[left, right]` range
3. Avoid integer overflow: use `left + (right - left) / 2`

### For Array Problems:
1. Consider sorting if order doesn't matter
2. Two-pointer technique for sorted arrays
3. Prefix sum for range queries
4. Hash maps for O(1) lookups

### Common Mistakes to Avoid:
1. Not handling duplicates in 3Sum
2. Off-by-one errors in binary search
3. Integer overflow in sum calculations
4. Not considering empty arrays or single elements

---

## Complexity Cheat Sheet

| Algorithm | Time | Space | Use Case |
|-----------|------|-------|----------|
| Lower Bound | O(log n) | O(1) | Sorted array search |
| Upper Bound | O(log n) | O(1) | Sorted array search |
| 3Sum | O(n²) | O(1) | Triplet finding |
| Pivot Index | O(n) | O(1) | Balance point |
| Running Sum | O(n) | O(1) or O(n) | Prefix sum queries |

---
