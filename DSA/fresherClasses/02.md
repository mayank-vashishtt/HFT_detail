# Understanding `unordered_set<int>` in C++

## What is `unordered_set`?

An `unordered_set` is a container in C++ that stores **unique elements** in no particular order. Think of it as a collection where:
- **No duplicates allowed** - each element appears only once
- **No specific order** - elements aren't sorted
- **Fast lookups** - checking if an element exists is very quick (O(1) average)

---

## Basic Syntax

```cpp
#include <unordered_set>
using namespace std;

unordered_set<int> seen;  // Creates an empty set of integers
```

---

## Core Operations (Beginner Level)

### 1. Insert Elements
```cpp
unordered_set<int> seen;
seen.insert(5);      // Adds 5
seen.insert(10);     // Adds 10
seen.insert(5);      // Does nothing (5 already exists)
// Set now contains: {5, 10}
```

### 2. Check if Element Exists
```cpp
if (seen.find(5) != seen.end()) {
    cout << "5 exists in the set!";
} else {
    cout << "5 doesn't exist";
}

// Alternative (C++20)
if (seen.contains(5)) {
    cout << "5 exists!";
}
```

### 3. Remove Elements
```cpp
seen.erase(5);  // Removes 5 from the set
```

### 4. Check Size
```cpp
int size = seen.size();        // Returns number of elements
bool isEmpty = seen.empty();    // Returns true if empty
```

### 5. Clear All Elements
```cpp
seen.clear();  // Removes all elements
```

---

## Common Use Cases

### Use Case 1: **Detect Duplicates in Array**
**Problem:** Check if an array has duplicate values

```cpp
bool hasDuplicate(vector<int>& nums) {
    unordered_set<int> seen;
    
    for (int num : nums) {
        if (seen.find(num) != seen.end()) {
            return true;  // Found duplicate!
        }
        seen.insert(num);
    }
    return false;  // No duplicates
}

// Example:
// Input: [1, 2, 3, 4, 5] → false
// Input: [1, 2, 3, 2, 5] → true (2 appears twice)
```

---

### Use Case 2: **Find Missing Number**
**Problem:** Numbers from 1 to n, one is missing. Find it.

```cpp
int findMissing(vector<int>& nums, int n) {
    unordered_set<int> seen(nums.begin(), nums.end());
    
    for (int i = 1; i <= n; i++) {
        if (seen.find(i) == seen.end()) {
            return i;  // This number is missing
        }
    }
    return -1;
}

// Example:
// Input: [1, 2, 4, 5], n=5 → Output: 3
```

---

### Use Case 3: **Two Sum Problem**
**Problem:** Find if two numbers add up to target

```cpp
bool twoSum(vector<int>& nums, int target) {
    unordered_set<int> seen;
    
    for (int num : nums) {
        int complement = target - num;
        if (seen.find(complement) != seen.end()) {
            return true;  // Found pair!
        }
        seen.insert(num);
    }
    return false;
}

// Example:
// Input: [2, 7, 11, 15], target=9 → true (2+7=9)
```

---

### Use Case 4: **Remove Duplicates from Array**
**Problem:** Keep only unique elements

```cpp
vector<int> removeDuplicates(vector<int>& nums) {
    unordered_set<int> seen(nums.begin(), nums.end());
    return vector<int>(seen.begin(), seen.end());
}

// Example:
// Input: [1, 2, 2, 3, 4, 4, 5] → Output: [1, 2, 3, 4, 5]
```

---

### Use Case 5: **Check if Array is Subset**
**Problem:** Check if all elements of arr1 exist in arr2

```cpp
bool isSubset(vector<int>& arr1, vector<int>& arr2) {
    unordered_set<int> set2(arr2.begin(), arr2.end());
    
    for (int num : arr1) {
        if (set2.find(num) == set2.end()) {
            return false;  // Element not found in arr2
        }
    }
    return true;
}

// Example:
// arr1 = [1, 2, 3], arr2 = [1, 2, 3, 4, 5] → true
// arr1 = [1, 6], arr2 = [1, 2, 3, 4, 5] → false (6 not in arr2)
```

---

## Iteration Over `unordered_set`

```cpp
unordered_set<int> seen = {5, 10, 15, 20};

// Method 1: Range-based for loop
for (int num : seen) {
    cout << num << " ";
}

// Method 2: Iterator
for (auto it = seen.begin(); it != seen.end(); ++it) {
    cout << *it << " ";
}
```

**Note:** Order is **not guaranteed**! Output might be: `20 5 15 10`

---

## Advanced Concepts

### Time Complexity
| Operation | Average Case | Worst Case |
|-----------|-------------|------------|
| Insert    | O(1)        | O(n)       |
| Search    | O(1)        | O(n)       |
| Delete    | O(1)        | O(n)       |

### How It Works Internally
- Uses **hash table** (like a dictionary with keys only)
- Computes hash of each element to find its "bucket"
- Fast average-case performance due to hashing

### Custom Hash Functions (Advanced)
For custom objects, you need to define hash function:

```cpp
struct Person {
    string name;
    int age;
};

struct PersonHash {
    size_t operator()(const Person& p) const {
        return hash<string>()(p.name) ^ hash<int>()(p.age);
    }
};

unordered_set<Person, PersonHash> people;
```

---

## `unordered_set` vs Other Containers

| Feature | `unordered_set` | `set` | `vector` |
|---------|-----------------|-------|----------|
| Ordered | ❌ No | ✅ Yes | ✅ Yes (by index) |
| Unique Elements | ✅ Yes | ✅ Yes | ❌ No |
| Search Speed | O(1) avg | O(log n) | O(n) |
| Use When | Need fast lookup of unique elements | Need sorted unique elements | Need indexed access or duplicates |

---

## Common Mistakes to Avoid

### Mistake 1: Assuming Order
```cpp
unordered_set<int> s = {1, 2, 3, 4, 5};
// DON'T expect output to be 1 2 3 4 5
// Order is unpredictable!
```

### Mistake 2: Modifying During Iteration
```cpp
// WRONG!
for (int num : seen) {
    seen.erase(num);  // Can cause undefined behavior
}
```

### Mistake 3: Using with Non-Hashable Types
```cpp
// Won't compile without custom hash function
unordered_set<vector<int>> s;  // ❌ Error!
```

---

## Quick Reference Cheatsheet

```cpp
#include <unordered_set>

unordered_set<int> s;

// Insert
s.insert(5);

// Check existence
if (s.find(5) != s.end()) { }
if (s.contains(5)) { }  // C++20

// Count (returns 0 or 1)
if (s.count(5)) { }

// Remove
s.erase(5);

// Size
int size = s.size();

// Clear all
s.clear();

// Initialize with values
unordered_set<int> s2 = {1, 2, 3, 4, 5};
unordered_set<int> s3(vec.begin(), vec.end());
```

---

## Practice Problems

1. **Easy:** Remove duplicates from an array
2. **Easy:** Check if array contains duplicate elements
3. **Medium:** Find intersection of two arrays
4. **Medium:** Longest consecutive sequence
5. **Hard:** Check if array can be divided into pairs with difference k

---

## Summary

`unordered_set` is perfect when you need:
- ✅ Store unique values
- ✅ Fast lookup (check if element exists)
- ✅ Don't care about order
- ✅ Prevent duplicates automatically

Use `set` if you need sorted order, use `vector` if you need duplicates or indexed access!