# Complete Two Pointers Guide üéØ

## Table of Contents
1. [Introduction to Two Pointers](#introduction)
2. [Problem 1: Two Sum](#two-sum)
3. [Problem 2: Valid Palindrome](#valid-palindrome)
4. [Two Pointers Patterns](#two-pointers-patterns)
5. [Problem Progression (Easy to Hard)](#problem-progression)

---

## Introduction to Two Pointers {#introduction}

The **Two Pointers** technique is a powerful algorithmic pattern used to solve array/string problems efficiently. Instead of using nested loops (O(n¬≤)), we use two pointers to traverse the data structure, reducing time complexity to O(n).

### Core Concept
- Use two pointers (indices) to traverse data
- Pointers move based on specific conditions
- Reduces time complexity from O(n¬≤) to O(n) or O(nlogn)

### When to Use Two Pointers?
‚úÖ Sorted arrays or strings  
‚úÖ Finding pairs/triplets with specific sum  
‚úÖ Palindrome checking  
‚úÖ Removing duplicates  
‚úÖ Container/window problems  

---

## Problem 1: Two Sum {#two-sum}

### Problem Statement
Given an array of integers `nums` and an integer `target`, return indices of two numbers that add up to `target`.

**Example:**
```
Input: nums = [2,7,11,15], target = 9
Output: [0,1]
Explanation: nums[0] + nums[1] = 2 + 7 = 9
```

### Approach Evolution

#### ‚ùå Brute Force: O(n¬≤)
```cpp
// Check every pair - inefficient
for(int i = 0; i < n; i++) {
    for(int j = i+1; j < n; j++) {
        if(nums[i] + nums[j] == target)
            return {i, j};
    }
}
```

#### ‚ö†Ô∏è Two Pointers: O(nlogn) - Won't Work Here!
**Why doesn't two pointers work for this problem?**
- Two pointers requires **sorted array**
- If we sort the array, we **lose original indices**
- Problem specifically asks for indices
- Sorting changes: `[2,7,11,15]` ‚Üí positions change

#### ‚úÖ HashMap Solution: O(n) - Best Approach!

```cpp
unordered_map<int, int> map;  // {value -> index}

for(int i = 0; i < nums.size(); i++) {
    int need = target - nums[i];  // complement we're looking for
    
    if(map.count(need)) {
        return {map[need], i};  // found pair!
    }
    
    map[nums[i]] = i;  // store current number with its index
}
return {};
```

### Detailed Walkthrough

**Example: nums = [2,7,11,15], target = 9**

| Step | i | nums[i] | need | map before | Action |
|------|---|---------|------|------------|--------|
| 1 | 0 | 2 | 7 | {} | 7 not in map, add {2:0} |
| 2 | 1 | 7 | 2 | {2:0} | 2 found! Return [0,1] |

**Key Insights:**
1. **Why HashMap?** - O(1) lookup for complement
2. **Why not Set?** - Set only stores values, we need indices
3. **One Pass** - Check and insert in same loop
4. **Store after checking** - Avoids using same element twice

### Why HashMap > Two Pointers Here?

| Approach | Time | Space | Index Preservation |
|----------|------|-------|-------------------|
| Brute Force | O(n¬≤) | O(1) | ‚úÖ |
| Two Pointers | O(nlogn) | O(1) | ‚ùå (sorting destroys) |
| HashMap | O(n) | O(n) | ‚úÖ |

---

## Problem 2: Valid Palindrome {#valid-palindrome}

### Problem Statement
Check if a phrase is a palindrome (reads same forward and backward), considering only alphanumeric characters and ignoring cases.

**Example:**
```
Input: s = "A man, a plan, a canal: Panama"
Output: true
Explanation: "amanaplanacanalpanama" is a palindrome
```

### Why Two Pointers Works Here?

Unlike Two Sum, this problem:
- ‚úÖ Doesn't need to return indices
- ‚úÖ Just needs YES/NO answer
- ‚úÖ Can traverse from both ends simultaneously
- ‚úÖ No sorting required (checking in place)

### Solution with Two Pointers: O(n)

```cpp
int left = 0;
int right = s.length() - 1;

while(left < right) {
    char left_char = s[left];
    char right_char = s[right];
    
    // Skip non-alphanumeric from left
    if(!isalnum(left_char)) {
        left++;
    }
    // Skip non-alphanumeric from right
    else if(!isalnum(right_char)) {
        right--;
    }
    // Compare characters (case-insensitive)
    else if(tolower(left_char) != tolower(right_char)) {
        return false;
    }
    // Characters match, move both pointers
    else {
        left++;
        right--;
    }
}

return true;
```

### Step-by-Step Execution

**Input: "A man, a plan, a canal: Panama"**

```
Step 1: left=0 ('A'), right=30 ('a')
        ‚Üí Both alphanumeric, tolower('A')='a', tolower('a')='a' ‚úì
        ‚Üí Move both: left=1, right=29

Step 2: left=1 (' '), right=29 ('m')
        ‚Üí left is not alphanumeric, skip
        ‚Üí left=2

Step 3: left=2 ('m'), right=29 ('m')
        ‚Üí Both match ‚úì
        ‚Üí left=3, right=28

... continues until left >= right
```

### Key Functions Used

```cpp
isalnum(char c)    // Checks if alphanumeric (a-z, A-Z, 0-9)
tolower(char c)    // Converts to lowercase
```

### Why This Approach is Optimal

1. **Single Pass**: O(n) - visit each character once
2. **No Extra Space**: O(1) - only two pointers
3. **Early Exit**: Return false immediately on mismatch
4. **Handles Edge Cases**: Spaces, punctuation, mixed case

---

## Two Pointers Patterns {#two-pointers-patterns}

### Pattern 1: Opposite Direction (Collision)
**Pointers start at opposite ends and move toward each other**

```cpp
int left = 0;
int right = n - 1;

while(left < right) {
    // Process and move pointers
    left++;
    right--;
}
```

**Use Cases:**
- Palindrome checking ‚úì
- Two Sum (sorted array)
- Container with most water
- Trapping rain water

**Visual:**
```
[1, 2, 3, 4, 5, 6]
 ‚Üë              ‚Üì
left          right
```

---

### Pattern 2: Same Direction (Slow-Fast Pointers)
**Both pointers start at beginning, move at different speeds**

```cpp
int slow = 0;
int fast = 0;

while(fast < n) {
    // Fast explores, slow tracks valid elements
    if(condition) {
        nums[slow] = nums[fast];
        slow++;
    }
    fast++;
}
```

**Use Cases:**
- Remove duplicates
- Remove element
- Move zeros to end
- Linked list cycle detection

**Visual:**
```
[0, 1, 2, 2, 3, 4]
 ‚Üë     ‚Üë
slow  fast
```

---

### Pattern 3: Sliding Window
**Two pointers maintain a window of elements**

```cpp
int left = 0;

for(int right = 0; right < n; right++) {
    // Expand window
    add(nums[right]);
    
    // Shrink window if needed
    while(invalid_condition) {
        remove(nums[left]);
        left++;
    }
    
    // Process current window
}
```

**Use Cases:**
- Longest substring without repeating characters
- Minimum window substring
- Maximum sum subarray of size k

---

### Pattern 4: Fast-Faster (Floyd's Cycle Detection)
**Two pointers move at 1x and 2x speed**

```cpp
ListNode* slow = head;
ListNode* fast = head;

while(fast && fast->next) {
    slow = slow->next;        // Move 1 step
    fast = fast->next->next;  // Move 2 steps
    
    if(slow == fast) {
        return true;  // Cycle detected
    }
}
return false;
```

**Use Cases:**
- Detect cycle in linked list
- Find middle of linked list
- Find cycle start point

---

## Problem Progression (Easy to Hard) {#problem-progression}

### üü¢ Easy Level

#### 1. **Remove Duplicates from Sorted Array**
```cpp
// Pattern: Slow-Fast
int removeDuplicates(vector<int>& nums) {
    int slow = 0;
    for(int fast = 1; fast < nums.size(); fast++) {
        if(nums[fast] != nums[slow]) {
            slow++;
            nums[slow] = nums[fast];
        }
    }
    return slow + 1;
}
```

#### 2. **Move Zeroes**
```cpp
// Pattern: Slow-Fast
void moveZeroes(vector<int>& nums) {
    int slow = 0;
    for(int fast = 0; fast < nums.size(); fast++) {
        if(nums[fast] != 0) {
            swap(nums[slow], nums[fast]);
            slow++;
        }
    }
}
```

#### 3. **Reverse String**
```cpp
// Pattern: Opposite Direction
void reverseString(vector<char>& s) {
    int left = 0, right = s.size() - 1;
    while(left < right) {
        swap(s[left++], s[right--]);
    }
}
```

#### 4. **Valid Palindrome** ‚úì (Already covered above)

#### 5. **Linked List Cycle**
```cpp
// Pattern: Fast-Faster (Floyd's)
bool hasCycle(ListNode *head) {
    ListNode *slow = head, *fast = head;
    while(fast && fast->next) {
        slow = slow->next;
        fast = fast->next->next;
        if(slow == fast) return true;
    }
    return false;
}
```

---

### üü° Medium Level

#### 6. **3Sum**
```cpp
// Pattern: Opposite Direction + Iteration
vector<vector<int>> threeSum(vector<int>& nums) {
    sort(nums.begin(), nums.end());
    vector<vector<int>> result;
    
    for(int i = 0; i < nums.size() - 2; i++) {
        if(i > 0 && nums[i] == nums[i-1]) continue; // Skip duplicates
        
        int left = i + 1, right = nums.size() - 1;
        while(left < right) {
            int sum = nums[i] + nums[left] + nums[right];
            if(sum == 0) {
                result.push_back({nums[i], nums[left], nums[right]});
                while(left < right && nums[left] == nums[left+1]) left++;
                while(left < right && nums[right] == nums[right-1]) right--;
                left++; right--;
            }
            else if(sum < 0) left++;
            else right--;
        }
    }
    return result;
}
```

#### 7. **Container With Most Water**
```cpp
// Pattern: Opposite Direction
int maxArea(vector<int>& height) {
    int left = 0, right = height.size() - 1;
    int maxWater = 0;
    
    while(left < right) {
        int h = min(height[left], height[right]);
        int width = right - left;
        maxWater = max(maxWater, h * width);
        
        // Move pointer with smaller height
        if(height[left] < height[right]) left++;
        else right--;
    }
    return maxWater;
}
```

#### 8. **Longest Substring Without Repeating Characters**
```cpp
// Pattern: Sliding Window
int lengthOfLongestSubstring(string s) {
    unordered_set<char> window;
    int left = 0, maxLen = 0;
    
    for(int right = 0; right < s.length(); right++) {
        while(window.count(s[right])) {
            window.erase(s[left]);
            left++;
        }
        window.insert(s[right]);
        maxLen = max(maxLen, right - left + 1);
    }
    return maxLen;
}
```

#### 9. **Sort Colors (Dutch National Flag)**
```cpp
// Pattern: Three Pointers
void sortColors(vector<int>& nums) {
    int low = 0, mid = 0, high = nums.size() - 1;
    
    while(mid <= high) {
        if(nums[mid] == 0) {
            swap(nums[low], nums[mid]);
            low++; mid++;
        }
        else if(nums[mid] == 1) {
            mid++;
        }
        else {
            swap(nums[mid], nums[high]);
            high--;
        }
    }
}
```

---

### üî¥ Hard Level

#### 10. **Trapping Rain Water**
```cpp
// Pattern: Opposite Direction
int trap(vector<int>& height) {
    int left = 0, right = height.size() - 1;
    int leftMax = 0, rightMax = 0;
    int water = 0;
    
    while(left < right) {
        if(height[left] < height[right]) {
            if(height[left] >= leftMax) {
                leftMax = height[left];
            } else {
                water += leftMax - height[left];
            }
            left++;
        } else {
            if(height[right] >= rightMax) {
                rightMax = height[right];
            } else {
                water += rightMax - height[right];
            }
            right--;
        }
    }
    return water;
}
```

#### 11. **Minimum Window Substring**
```cpp
// Pattern: Sliding Window
string minWindow(string s, string t) {
    unordered_map<char, int> required, window;
    for(char c : t) required[c]++;
    
    int left = 0, formed = 0;
    int minLen = INT_MAX, minStart = 0;
    
    for(int right = 0; right < s.length(); right++) {
        char c = s[right];
        window[c]++;
        
        if(required.count(c) && window[c] == required[c])
            formed++;
        
        while(formed == required.size()) {
            if(right - left + 1 < minLen) {
                minLen = right - left + 1;
                minStart = left;
            }
            
            char leftChar = s[left];
            window[leftChar]--;
            if(required.count(leftChar) && window[leftChar] < required[leftChar])
                formed--;
            left++;
        }
    }
    
    return minLen == INT_MAX ? "" : s.substr(minStart, minLen);
}
```

#### 12. **Substring with Concatenation of All Words**
```cpp
// Pattern: Sliding Window + HashMap
vector<int> findSubstring(string s, vector<string>& words) {
    // Complex sliding window with word boundaries
    // Track exact word matches in sliding window
    // Time: O(n * m) where m = word length
}
```

---

## Complexity Analysis Cheat Sheet

| Pattern | Time Complexity | Space Complexity | When to Use |
|---------|----------------|------------------|-------------|
| Opposite Direction | O(n) | O(1) | Sorted arrays, palindromes |
| Slow-Fast | O(n) | O(1) | Remove elements, duplicates |
| Sliding Window | O(n) | O(k) | Substrings, subarrays |
| Floyd's Cycle | O(n) | O(1) | Linked list problems |

---

## Common Pitfalls & Tips

### ‚ö†Ô∏è Common Mistakes

1. **Off-by-one errors**
   ```cpp
   // Wrong
   while(left <= right)  // May process same element twice
   
   // Correct
   while(left < right)
   ```

2. **Forgetting to move pointers**
   ```cpp
   // Infinite loop!
   while(left < right) {
       if(condition) {
           // Forgot left++ or right--
       }
   }
   ```

3. **Not handling edge cases**
   - Empty array/string
   - Single element
   - All same elements

### üí° Pro Tips

1. **Draw it out**: Visualize pointer movement
2. **Test with examples**: Walk through step-by-step
3. **Think about invariants**: What's true at each iteration?
4. **Consider sorting**: Does sorting help? Will it break the problem?
5. **Space-time tradeoff**: Sometimes O(n) space for O(n) time is worth it

---

## Summary

### When to Use Each Approach

| Problem Needs | Best Approach |
|---------------|---------------|
| Return indices | HashMap (can't sort) |
| Yes/No answer on sorted data | Two Pointers |
| Subarray/substring problems | Sliding Window |
| Linked list cycle | Floyd's Algorithm |
| Remove/modify in-place | Slow-Fast |

### Key Takeaways

1. **Two Pointers** reduces O(n¬≤) to O(n)
2. **Choose pattern** based on problem type
3. **Can't always use** two pointers (like Two Sum with indices)
4. **Practice identifying** which pattern fits
5. **Master the basics** before moving to hard problems

---
