# ğŸš€ Unordered Map & Unordered Set

---

## ğŸ¯ Why Do We Need Them?

### The Search Problem:

| Data Structure | Search Time                |
| -------------- | -------------------------- |
| **Array**      | O(n) â€“ check every element |
| **Hash Table** | O(1) â€“ instant lookup!     |

**Real-world analogy:**

* **Array** â†’ Like a notebook where you write things sequentially.
  To find â€œJohnâ€™s phone number,â€ you flip through every page.
* **Hash Map** â†’ Like a phone book with alphabetical sections.
  Know the name? Jump directly to that section!

---

## ğŸ”‘ Hash Tables: The Foundation

A **hash table** uses a **hash function** to convert keys into array indices.
**Hash Function:** `key â†’ hash code â†’ index`

**Example:**

```
"apple"  â†’ hash_function("apple")  â†’ 47  â†’ array[47]
"banana" â†’ hash_function("banana") â†’ 123 â†’ array[123]
```

**Visual:**

```
Keys:   "apple"  "banana"  "cherry"
         â†“         â†“          â†“
Hash:   47       123        89
         â†“         â†“          â†“
Array: [____][____][apple]...[banana]...[cherry]
        0    1     47        123       89
```

---

## ğŸ“¦ Unordered Set

### Definition:

A **collection of unique elements** with **O(1)** average lookup time.

### ğŸ”¹ Key Properties:

* âœ… No duplicates allowed
* âœ… Unordered (no specific sequence)
* âœ… Fast lookup â†’ O(1) average
* âœ… Fast insertion/deletion â†’ O(1) average

---

### ğŸ’» Basic Operations

```cpp
#include <unordered_set>
using namespace std;

unordered_set<int> mySet;

// 1. INSERT
mySet.insert(5);
mySet.insert(10);
mySet.insert(5);  // Duplicate ignored!

// 2. CHECK existence
if(mySet.count(5)) {
    cout << "5 exists!";
}

// 3. REMOVE
mySet.erase(10);

// 4. SIZE
cout << mySet.size();

// 5. ITERATE
for(int x : mySet) cout << x << " ";

// 6. CLEAR
mySet.clear();

// 7. EMPTY
if(mySet.empty()) cout << "Set is empty";
```

---

### ğŸ® Example: Find Duplicates

```cpp
// âœ… Using Unordered Set: O(n)
bool containsDuplicate(vector<int>& nums) {
    unordered_set<int> seen;
    for(int num : nums) {
        if(seen.count(num)) return true;
        seen.insert(num);
    }
    return false;
}
```

**Visual Walkthrough:**

```
nums = [1, 2, 3, 1]

Step 1: num=1 â†’ seen={} â†’ insert 1 â†’ seen={1}
Step 2: num=2 â†’ seen={1} â†’ insert 2 â†’ seen={1,2}
Step 3: num=3 â†’ seen={1,2} â†’ insert 3 â†’ seen={1,2,3}
Step 4: num=1 â†’ seen={1,2,3} â†’ found duplicate âœ…
```

---

### ğŸ”¥ Common Use Cases for `unordered_set`

#### 1. Remove Duplicates

```cpp
vector<int> removeDuplicates(vector<int>& nums) {
    unordered_set<int> uniqueSet(nums.begin(), nums.end());
    return vector<int>(uniqueSet.begin(), uniqueSet.end());
}
```

#### 2. Find Intersection of Two Arrays

```cpp
vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {
    unordered_set<int> set1(nums1.begin(), nums1.end());
    unordered_set<int> result;
    for(int num : nums2)
        if(set1.count(num)) result.insert(num);
    return vector<int>(result.begin(), result.end());
}
```

#### 3. Check if Array is Subset of Another

```cpp
bool isSubset(vector<int>& arr1, vector<int>& arr2) {
    unordered_set<int> set2(arr2.begin(), arr2.end());
    for(int num : arr1)
        if(!set2.count(num)) return false;
    return true;
}
```

---

## ğŸ—Ÿï¸ Unordered Map

### Definition:

Stores **key-value pairs** with **O(1)** average lookup by key.

### ğŸ”¹ Key Properties:

* âœ… Keys are unique (values can repeat)
* âœ… Unordered
* âœ… Fast lookup by key (O(1))
* âœ… Flexible key/value types

---

### ğŸ’» Basic Operations

```cpp
#include <unordered_map>
using namespace std;

unordered_map<string, int> myMap;

// 1. INSERT
myMap["apple"] = 5;
myMap["banana"] = 3;
myMap.insert({"cherry", 8});

// 2. ACCESS
cout << myMap["apple"]; // 5

// 3. CHECK existence
if(myMap.count("apple")) cout << "Exists!";

// 4. UPDATE
myMap["apple"] = 10;

// 5. ERASE
myMap.erase("banana");

// 6. SIZE
cout << myMap.size();

// 7. ITERATE
for(auto& p : myMap)
    cout << p.first << ": " << p.second << endl;

// 8. CLEAR
myMap.clear();
```

---

### ğŸ® Example: Character Frequency Count

```cpp
unordered_map<char, int> countFrequency(string s) {
    unordered_map<char, int> freq;
    for(char c : s) freq[c]++;
    return freq;
}

// Usage
string s = "hello";
auto freq = countFrequency(s);
for(auto& p : freq) cout << p.first << ":" << p.second << " ";
```

**Output:**

```
h:1 e:1 l:2 o:1
```

**Visual:**

```
s = "hello"

'h' -> 1
'e' -> 1
'l' -> 2
'o' -> 1
```

---

### ğŸ”¥ Common Use Cases for `unordered_map`

#### 1. Two Sum Problem

```cpp
vector<int> twoSum(vector<int>& nums, int target) {
    unordered_map<int, int> seen;  // {value : index}
    for(int i = 0; i < nums.size(); i++) {
        int complement = target - nums[i];
        if(seen.count(complement)) return {seen[complement], i};
        seen[nums[i]] = i;
    }
    return {};
}
```

#### 2. First Non-Repeating Character

```cpp
char firstUniqChar(string s) {
    unordered_map<char, int> freq;
    for(char c : s) freq[c]++;
    for(char c : s)
        if(freq[c] == 1) return c;
    return '\0';
}
```

#### 3. Group Anagrams

```cpp
vector<vector<string>> groupAnagrams(vector<string>& strs) {
    unordered_map<string, vector<string>> groups;
    for(string s : strs) {
        string key = s;
        sort(key.begin(), key.end());
        groups[key].push_back(s);
    }
    vector<vector<string>> result;
    for(auto& pair : groups)
        result.push_back(pair.second);
    return result;
}
```

#### 4. Isomorphic Strings

```cpp
bool isIsomorphic(string s, string t) {
    if(s.length() != t.length()) return false;
    unordered_map<char, char> mapS, mapT;
    for(int i = 0; i < s.length(); i++) {
        char c1 = s[i], c2 = t[i];
        if(mapS.count(c1) && mapS[c1] != c2) return false;
        if(mapT.count(c2) && mapT[c2] != c1) return false;
        mapS[c1] = c2;
        mapT[c2] = c1;
    }
    return true;
}
```

---

## ğŸ…¿ï¸ Set vs Map Comparison

| Feature    | Unordered Set        | Unordered Map                  |
| ---------- | -------------------- | ------------------------------ |
| Stores     | Single values        | Key-value pairs                |
| Uniqueness | All elements unique  | Keys unique, values can repeat |
| Access     | Check existence only | Access value by key            |
| Use Case   | Membership testing   | Storing associations           |
| Example    | `{1, 2, 3}`          | `{{"a", 1}, {"b", 2}}`         |

---

## ğŸ…¿ï¸ Unordered vs Ordered

| Type            | Internal Structure | Time Complexity | Ordered? |
| --------------- | ------------------ | --------------- | -------- |
| `unordered_set` | Hash Table         | O(1) avg        | âŒ No     |
| `set`           | Red-Black Tree     | O(log n)        | âœ… Yes    |
| `unordered_map` | Hash Table         | O(1) avg        | âŒ No     |
| `map`           | Red-Black Tree     | O(log n)        | âœ… Yes    |

**When to use what?**

* Need **fast lookup** â†’ Use **Unordered (hash table)**
* Need **sorted order** â†’ Use **Ordered (tree)**
* Need **range queries** â†’ Use **Ordered (tree)**

```cpp
// Unordered: {3, 1, 4, 2} â†’ might store as {2, 4, 1, 3}
unordered_set<int> uset = {3, 1, 4, 2};

// Ordered: {3, 1, 4, 2} â†’ stored as {1, 2, 3, 4}
set<int> oset = {3, 1, 4, 2};
```

---

## âš ï¸ Important Notes

### Hash Collisions

```cpp
"abc" â†’ hash() â†’ 47
"xyz" â†’ hash() â†’ 47  // Collision!

// Handled internally by chaining or open addressing
Array[47] = [("abc", val1), ("xyz", val2)]
```

### When to Avoid Unordered Map/Set

```cpp
struct Person {
    string name;
    int age;
};

unordered_set<Person> people;  // ERROR: No hash function!

// âœ… Provide hash function
struct PersonHash {
    size_t operator()(const Person& p) const {
        return hash<string>()(p.name) ^ hash<int>()(p.age);
    }
};

unordered_set<Person, PersonHash> people;  // Works!
```

### Worst Case Performance

```cpp
// Average: O(1)
// Worst case (many collisions): O(n)
```

---

## ğŸ“Š Complexity Cheat Sheet

| Operation | Average | Worst Case |
| --------- | ------- | ---------- |
| Insert    | O(1)    | O(n)       |
| Delete    | O(1)    | O(n)       |
| Search    | O(1)    | O(n)       |
| Space     | O(n)    | O(n)       |

---
